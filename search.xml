<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>力扣贪心题目</title>
      <link href="/post/9a4e591a.html"/>
      <url>/post/9a4e591a.html</url>
      
        <content type="html"><![CDATA[<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p><a href="https://leetcode.cn/problems/largest-palindromic-number/"><strong>力扣2384：最大回文数字</strong></a></p><blockquote><p>给你一个仅由数字（0 - 9）组成的字符串 num 。请你找出能够使用 num 中数字形成的 <strong>最大回文</strong> 整数，并以字符串形式返回。该整数不含 <strong>前导零</strong> 。<br>注意：你 无需 使用 num 中的所有数字，但你必须使用 至少 一个数字。数字可以重新排序。</p><p>示例1：<br>输入：num &#x3D; “444947137”<br>输出：”7449447”</p><p>示例2：<br>输入：num &#x3D; “00009”<br>输出：”9”</p></blockquote><p><strong>思路</strong>：贪心。统计每个数字出现的次数，从大的开始选，如果数字次数大于1，则选两个，放在头尾，最后再选一个最大的放在中间。注意边界条件，如果只有0的次数大于1，则直接选一个最大的作为答案。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">largestPalindromic</span><span class="params">(String num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num.length();</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">// 统计每个数出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> num.charAt(i);</span><br><span class="line">            count[c - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">9</span>; <span class="comment">// 从大的开始选,这种形式是最大的98765...56789，优先把大的放在开头和结尾</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ansLeft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (p &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况，只有0的次数大于1</span></span><br><span class="line">            <span class="keyword">if</span> (ansLeft.length() == <span class="number">0</span> &amp;&amp; p == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (count[p] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                ansLeft.append(p);</span><br><span class="line">                count[p] -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只剩单个(可能没有),选一个最大的放中间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">9</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                max = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">// 如果不剩单个的了，直接左右拼接</span></span><br><span class="line">        <span class="keyword">if</span> (max != -<span class="number">1</span>) &#123;</span><br><span class="line">            ans.append(ansLeft).append(max).append(ansLeft.reverse());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans.append(ansLeft).append(ansLeft.reverse());  <span class="comment">// 有单个，放中间一起拼接</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 力扣 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分答案相关题目</title>
      <link href="/post/171c57a9.html"/>
      <url>/post/171c57a9.html</url>
      
        <content type="html"><![CDATA[<h3 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h3><p><a href="https://leetcode.cn/problems/koko-eating-bananas/"><strong>力扣875：爱吃香蕉的珂珂</strong></a></p><blockquote><p>珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。珂珂可以决定她吃香蕉的速度 k （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。 珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。</p><p>示例 1：<br>输入：piles &#x3D; [3,6,7,11], h &#x3D; 8<br>输出：4</p></blockquote><p><strong>思路</strong>：二分答案。先将数组大到小排序，取最小速度0和最大速度为piles[n - 1]，作为速度的左右边界，然后使用二分法，缩小速度的区间，直到找到最小的速度。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> piles.length;</span><br><span class="line">        Arrays.sort(piles);</span><br><span class="line">        <span class="keyword">if</span> (h == n) <span class="keyword">return</span> piles[n - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = piles[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">hours</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="comment">// 遍历整个数组，求出在当前速度下吃完要多少小时</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                hours += Math.ceil(piles[i] * <span class="number">1.0</span> / mid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hours &lt;= h) right = mid; <span class="comment">// h小时内能吃完,速度够，修改速度右边界为mid</span></span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>; <span class="comment">// h小时内不能吃完，速度小了，修改速度左边界为mid + 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(NlogM)，n为数组piles长度，m为piles的最大值。二分查找执行O(logm)轮，每一轮需要O(n)时间求出每个速度下吃完需要的时间。</p><p><a href="https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/"><strong>力扣2616：最小化数对的最大差值</strong></a></p><blockquote><p>给你一个下标从 0 开始的整数数组 nums 和一个整数 p 。请你从 nums 中找到 p 个下标对，每个下标对对应数值取差值，你需要使得这 p 个差值的 <strong>最大值 最小</strong>。同时，你需要确保每个下标在这 p 个下标对中最多出现一次。对于一个下标对 i 和 j ，这一对的差值为 |nums[i] - nums[j]| ，其中 |x| 表示 x 的 绝对值 。请你返回 p 个下标对对应数值 <strong>最大差值</strong> 的 <strong>最小值</strong> 。</p><p>示例 1：<br>输入：nums &#x3D; [10,1,2,7,1,3], p &#x3D; 2<br>输出：1<br>解释：第一个下标对选择 1 和 4 ，第二个下标对选择 2 和 5 。<br>最大差值为 max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) &#x3D; max(0, 1) &#x3D; 1 。所以我们返回 1 。</p></blockquote><p><strong>思路</strong>：同上一题，使用二分答案方法。<strong>看到最小化最大值或者最大化最小值首先想到要用二分法。</strong></p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimizeMax</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 先排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, left = <span class="number">0</span>, right = nums[n - <span class="number">1</span>] - nums[<span class="number">0</span>];  <span class="comment">// 定义最大差值的左右边界</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 遍历整个数组，看看有多少对满足差值小于mid的数对</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i + <span class="number">1</span>] - nums[i] &lt;= mid) &#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &gt;= p) right = mid; <span class="comment">// 可以找到p对差值小于mid，修改右边界为mid</span></span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>; <span class="comment">// 不能找到p对，说明mid值太小了，左边界换成mid + 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(NlogC)，C为二分查找的上下限之差</p><p>其他相关题目：</p><ul><li><a href="https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/">力扣1283</a></li><li><a href="https://leetcode.cn/problems/minimum-time-to-complete-trips/">力扣2187</a></li><li><a href="https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/">力扣2226</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 力扣 </tag>
            
            <tag> 二分答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣1685 &amp; 2615 前缀和</title>
      <link href="/post/4a13a2d3.html"/>
      <url>/post/4a13a2d3.html</url>
      
        <content type="html"><![CDATA[<h3 id="前缀和使用"><a href="#前缀和使用" class="headerlink" title="前缀和使用"></a>前缀和使用</h3><p><a href="https://leetcode.cn/problems/sum-of-absolute-differences-in-a-sorted-array/"><strong>力扣1685：有序数组中差绝对值之和</strong></a></p><blockquote><p>给你一个<strong>非递减</strong>有序整数数组nums，请你建立并返回一个整数数组 result，它跟 nums 长度相同，且result[i] 等于 nums[i] 与数组中所有其他元素差的绝对值之和。换句话说， result[i] 等于 sum(|nums[i]-nums[j]|) ，其中 0 &lt;&#x3D; j &lt; nums.length 且 j !&#x3D; i （下标从 0 开始）。</p><p>示例 1：<br>输入：nums &#x3D; [2,3,5]<br>输出：[4,3,5]<br>解释：假设数组下标从 0 开始，那么<br>result[0] &#x3D; |2-2| + |2-3| + |2-5| &#x3D; 0 + 1 + 3 &#x3D; 4，<br>result[1] &#x3D; |3-2| + |3-3| + |3-5| &#x3D; 1 + 0 + 2 &#x3D; 3，<br>result[2] &#x3D; |5-2| + |5-3| + |5-5| &#x3D; 3 + 2 + 0 &#x3D; 5。</p></blockquote><p><strong>思路</strong>：因为数组是有序的, 对数任意一个数nums[i],在数nums[i]左边的数比nums[i]小, 在nums[i]右边的数比nums[i]大,因此, 计算nums[i]和其他数的差绝对值之和可以分割为两部分来进行计算.首先计算前缀和数组prefixSum[], prefixSum[i]表示前i个数之和.<br>对于nums[i]的左半部分, nums[i]与其他数的差绝对值之和可计算为:</p><p>sumOfLeftDifferences &#x3D; (i+1)*nums[i]-prefixSum[i];</p><p>对于nums[i]的右半部分, nums[i]与其他数的绝对值之和可计算为:</p><p>sumOfRightDifferences &#x3D; prefixSum[nums.length-1]-prefixSum[i]-nums[i]*(nums.length-1-i);</p><p>所以, 当前nums[i]与左右其他数的绝对值之和为:</p><p>sumOfDifferences &#x3D; sumOfLeftDifferences+sumOfRightDifferences;</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getSumAbsoluteDifferences(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] prefix = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 计算前缀和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            prefix[i] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算每个数的差绝对值之和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; +ia+i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (i + <span class="number">1</span>) * nums[i] - prefix[i]; <span class="comment">// 当前数与它左边的数的差之和</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> prefix[n - <span class="number">1</span>] - prefix[i] - nums[i] * (n - <span class="number">1</span> - i); <span class="comment">// 当前数与它右边的数的差之和</span></span><br><span class="line">            ans[i] = left + right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p><a href="https://leetcode.cn/problems/sum-of-distances/"><strong>力扣340周赛6360：等值距离之和</strong></a></p><blockquote><p>给你一个下标从 0 开始的整数数组 nums 。现有一个长度等于 nums.length 的数组 arr 。对于满足 nums[j] &#x3D;&#x3D; nums[i] 且 j !&#x3D; i 的所有 j ，arr[i] 等于所有 |i - j| 之和。如果不存在这样的 j ，则令 arr[i] 等于 0 。返回数组 arr 。</p><p>示例 1：<br>输入：nums &#x3D; [1,3,1,1,2]<br>输出：[5,0,3,4,0]</p><p>示例 2：<br>输入：nums &#x3D; [0,5,3]<br>输出：[0,0,0]</p></blockquote><p><strong>思路</strong>：arr[i]的值就是nums中nums[i] &#x3D;&#x3D; nums[j] &amp;&amp; j !&#x3D; i 的i - j的绝对值的和。暴力循环会超时。想同的数之间是相互影响的，把每种数出现的下标用哈希表存起来，再遍历哈希表，对每个数的出现下标进行求差的绝对值之和，就转化为上一题了。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span>[] distance(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">long</span>[] ans = <span class="keyword">new</span> <span class="title class_">long</span>[n];</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt;  map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 存储每种数出现的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = map.get(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">                list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(i);</span><br><span class="line">            map.put(nums[i], list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, List&lt;Integer&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = entry.getValue(); <span class="comment">//某个数出现的下标集合(有序的)</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> list.size();</span><br><span class="line">            <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">            <span class="comment">// 转化为数组，方便求前缀和</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); ++i) &#123;</span><br><span class="line">                arr[i] = list.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 前缀和</span></span><br><span class="line">            <span class="type">long</span>[] prefix = <span class="keyword">new</span> <span class="title class_">long</span>[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                s += arr[i];</span><br><span class="line">                prefix[i] = s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历每个下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">left</span> <span class="operator">=</span> (<span class="type">long</span>)(i + <span class="number">1</span>) * arr[i] - prefix[i]; <span class="comment">// 当前下标与它左边的下标的差之和</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">right</span> <span class="operator">=</span> prefix[len - <span class="number">1</span>] - prefix[i] - (<span class="type">long</span>)arr[i] * (len - <span class="number">1</span> - i); <span class="comment">// 当前下标与它右边的下标的差之和</span></span><br><span class="line">                ans[arr[i]] = left + right;  <span class="comment">// arr[i]就是ans的索引</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 力扣 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经</title>
      <link href="/post/98e6f621.html"/>
      <url>/post/98e6f621.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java开发面经"><a href="#Java开发面经" class="headerlink" title="Java开发面经"></a>Java开发面经</h1><h2 id="一、Java基础"><a href="#一、Java基础" class="headerlink" title="一、Java基础"></a>一、Java基础</h2><ol><li><p>Java中八种基本数据类型？</p><p><strong>byte</strong>（字节型8位）、<strong>short</strong>（短整型16位）、<strong>int</strong>（整型32位）、<strong>long</strong>（长整型64位）、<strong>float</strong>（单精度浮点型32位） <strong>double</strong> （双精度浮点型64位）、<strong>char</strong>（字符型16位）、<strong>boolean</strong>（布尔型1位）</p></li><li><p>static关键字？<br>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</p></li><li><p>面向对象三大特性？</p><ul><li><strong>封装</strong>。就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</li><li><strong>继承</strong>。使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。</li><li><strong>多态</strong>。它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。</li></ul></li><li><p>重载和重写的区别？</p><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。   </p><ul><li>重写发生在子类与父类之间, 重写方法<u>返回值</u>和<u>形参</u>都不能改变，与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分。<strong>即外壳不变，核心重写！</strong></li><li>重载是在一个类里面，<strong>方法名字相同，而参数不同</strong>。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。最常用的地方就是构造器的重载。</li></ul></li><li><p>抽象类和接口的区别？</p><ul><li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li><li>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。</li></ul></li><li><p>&#x3D;&#x3D;和equals的区别？<br>&#x3D;&#x3D;常用于相同的基本数据类型之间的比较（值），也可用于相同类型的对象之间的比较（比较的是两个对象的引用，也就是判断两个对象是否指向了同一块内存区域）；<br>equals方法主要用于两个对象之间，检测一个对象是否等于另一个对象。有两种情况：</p><ul><li>情况1，类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，比较的是引用。</li><li>情况2，类覆盖了equals()方法。比较内容是否相等。</li></ul></li><li><p>error和Exception的区别？<br>Exception：程序本身可以处理的异常，可以通过catch来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。<br>error：属于程序无法处理的错误 。例如，系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，一旦这类错误发生，通常应用程序会被终止。</p></li><li><p>BIO、NIO、AIO区别？</p><ul><li>BIO：同步并阻塞，在服务器中实现的模式为<strong>一个连接一个线程</strong>。也就是说，客户端有连接请求的时候，服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然这也可以通过线程池机制改善。BIO<strong>一般适用于连接数目小且固定的架构</strong>，这种方式对于服务器资源要求比较高，而且并发局限于应用中，是JDK1.4之前的唯一选择，但好在程序直观简单，易理解。</li><li>NIO：同步并非阻塞，在服务器中实现的模式为<strong>一个请求一个线程</strong>，也就是说，客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到有连接IO请求时才会启动一个线程进行处理。<strong>NIO一般适用于连接数目多且连接比较短（轻操作）的架构</strong>，并发局限于应用中，编程比较复杂，从JDK1.4开始支持。</li><li>AIO：异步并非阻塞，在服务器中实现的模式为<strong>一个有效请求一个线程</strong>，也就是说，客户端的IO请求都是通过操作系统先完成之后，再通知服务器应用去启动线程进行处理。AIO一般适用于连接数目多且连接比较长（重操作）的架构，充分调用操作系统参与并发操作，编程比较复杂，从JDK1.7开始支持。</li></ul></li><li><p>浅拷贝和深拷贝的区别？<br><strong>浅拷贝</strong>会复制对象的引用，而不是对象本身的内容。这意味着当对被复制对象进行修改时，原对象和复制对象都会受到影响。简单来说，浅拷贝只是复制了指针，而没有复制指针所指向的对象。<br><strong>深拷贝</strong>则是完全复制了对象及其内容。这意味着当对被复制对象进行修改时，原对象和复制对象是互相独立的，互不影响。深拷贝会递归地复制指针所指向的对象，直到所有的对象都被复制。</p></li><li><p>面向对象的五大基本原则？</p><ul><li><strong>单一职责原则</strong>：一个类只负责完成一个单一的职责或功能，不要把多个不同的职责耦合到一个类中，以便于提高代码的可读性、可维护性和可扩展性。</li><li><strong>开闭原则</strong>：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。即在不修改原有代码的前提下，通过扩展来增加新的功能。</li><li><strong>里氏替换原则</strong>：子类对象能够替换其父类对象，并且在不影响程序正确性的前提下，扩展父类的功能。</li><li><strong>接口隔离原则</strong>：客户端不应该被迫依赖于它们不使用的接口。</li><li><strong>依赖倒置原则</strong>：高层模块不应该依赖底层模块，它们应该都依赖于抽象接口或抽象类。即面向接口编程，而不是面向实现编程。</li></ul></li><li><p>值传递和引用传递？</p><ul><li>值传递是指传递的参数是原始数据类型或者不可变对象，传递的是<strong>参数值的副本</strong>。这样在函数内部对参数进行修改不会影响到函数外部的变量值。在 Java 中，基本数据类型和字符串都是采用值传递的方式传递参数</li><li>引用传递是指传递的参数是可变对象或者引用类型，传递的是<strong>参数引用的副本</strong>，也就是指向堆内存中的同一对象。这样在函数内部对参数进行修改会影响到函数外部的变量值。在 Java 中，数组、集合、自定义对象等都是采用引用传递的方式传递参数。</li></ul><p>需要注意的是，Java 中的引用传递并不是真正的引用传递，而是传递引用的副本。也就是说，实际传递的还是值，只不过这个值是指向对象的引用。</p></li><li><p>线程安全和不安全的集合？<br>线程安全的集合：HashTable, ConcurrentHashMap, Vector, Stack<br>线程不安全的集合：HashMap, ArrayList, LinkedList, HashSet, TreeSet, TreeMap</p></li><li><p>ArrayList和LinkedList异同？</p><ul><li>是否线程安全：ArrayList和LinkedList都不安全</li><li>底层数据结构：ArrayList底层是数组，LinkedList底层是双向循环链表</li><li>是否支持随机访问：ArrayList可以随机访问，LinkedList不能随机访问</li><li>插入和删除元素是否受位置影响：ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</li></ul></li><li><p>ArrayList和Vector的区别？</p><ul><li>Vector是线程安全的，ArrayList不是线程安全的。Vector在关键性的方法前面都加了synchronized关键字，来保证线程的安全性。如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</li><li>ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，<strong>Vector是扩展1倍</strong>，这样ArrayList就有利于节约内存空间。</li></ul></li><li><p>ArrayList的扩容机制？<br>ArrayList新建初始化时容量为0，当插入第一个元素时容量初始化为10，扩容时容量为原来的1.5倍。</p></li><li><p>Collections.sort和Arrays.sort的区别？</p><ul><li>参数类型不同：Collections.sort()方法的参数是List类型，而Arrays.sort()方法的参数是数组类型。</li><li>实现方式不同：Collections.sort()方法是对List类型进行排序的，它内部使用了<strong>归并排序</strong>（Merge Sort）算法，而Arrays.sort()方法是对数组类型进行排序的，它内部使用了<strong>快速排序</strong>（Quick Sort）算法。</li><li>排序效率不同：由于采用了不同的排序算法，因此在数据量较小的情况下，快速排序算法比归并排序算法更快，而在数据量较大的情况下，归并排序算法比快速排序算法更快。</li><li>可以排序的元素类型不同：Collections.sort()方法可以对包含任何类型的元素的List进行排序，而Arrays.sort()方法只能对基本类型和实现了Comparable接口的类进行排序。</li></ul></li><li><p>HashMap的底层数据结构是什么？</p><p>在JDK1.7 中，HashMap由“数组+链表”组成，在JDK1.8 中，由“数组+链表+红黑树”组成。当链表超过 8 且数组长度超过 64 才会转红黑树。</p></li><li><p>HashMap中key的存储索引怎么计算的？<br>首先根据key的值计算出hashcode的值，然后根据hashcode计算出hash值，最后通过hash&amp;（length-1）计算得到存储的位置。</p></li><li><p>HashMap扩容机制？<br>HashMap 在容量超过负载因子（0.75）所定义的容量之后，就会扩容。Java 里的数组是无法自动扩容的，方法是将 HashMap 的大小扩大为原来数组的<strong>两倍</strong>，并将原来的对象放入新的数组中。</p></li><li><p>HashMap为什么线程不安全？<br>多线程的put可能导致元素的丢失。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。</p><p>怎么使HashMap线程安全？<br>可以使用线程安全的 ConcurrentHashMap 类，或者在使用 HashMap 时采用同步机制，如使用 Collections.synchronizedMap 方法包装 HashMap 实例，使用对象锁来保证多线程场景下线程安全，但是这样会导致一定的性能损失。</p></li><li><p>红黑树？<br>红黑树是一种自平衡的二叉查找树，是一种高效的查找树。红黑树具有良好的效率，它可在 O(logN) 时间内完成查找、增加、删除等操作。</p><p>每个节点或者是红色的，或者是黑色的。根节点是黑色的。每个叶节点（NIL节点，空节点）是黑色的。如果一个节点是红色的，则它的子节点必须是黑色的。从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。通过这些特点，红黑树可以保证树的高度是平衡的，从而提高了树的搜索、插入、删除等操作的效率。</p><p>红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。而平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。</p></li><li><p>ConcurrentHashMap底层数据结构？<br>JDK1.7之前是<strong>分段数组+链表</strong>，JDK1.8之后和HashMap一样，为<strong>数组+链表+红黑树</strong>。<br>JDK1.7之前使用分段锁，JDK1.8抛弃了原有的 Segment 分段锁，采用CAS + synchronized实现更加低粒度的锁，在链表头结点或红黑树根节点加锁。</p></li></ol><h2 id="二、Java并发"><a href="#二、Java并发" class="headerlink" title="二、Java并发"></a>二、Java并发</h2><ol><li><p>进程和线程的区别？</p><ul><li>进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。</li><li>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</li><li>一个进程内有多个线程，线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li><li>同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的。</li><li>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li></ul></li><li><p>创建线程的三种方式？</p><ul><li>实现Runnable接口：重写run()方法，没有返回值</li><li>实现Callable接口：重写call()方法，有返回值</li><li>继承Thread类</li></ul></li><li><p>sleep()和wait()方法的异同？<br>sleep()：是Thread类的静态方法，当前线程将睡眠n毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进入可运行状态，等待CPU的到来。睡眠不释放锁（如果有的话）。<br>wait()：是Object的方法，必须与synchronized关键字一起使用，线程进入阻塞状态，当notify或者notifyall被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，会释放互斥锁。</p></li><li><p>Thread类中yield方法的作用？<br>yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。</p></li><li><p>volatile的使用及原理？<br>volatile<strong>保证变量对所有线程的可见性</strong>：当volatile变量被修改，新值对所有线程会立即更新。或者理解为多线程环境下使用volatile修饰的变量的值一定是最新的。</p><p><strong>原理</strong>：volatile 通过编译器在生成字节码时，在指令序列中添加” 内存屏障 “来禁止指令重排序的。</p><p>volatile的<strong>内存屏障</strong>指的是在使用volatile变量时，JVM需要插入一些特殊的指令，以<strong>确保多个线程之间的内存可见性和有序性</strong>。这些指令通常被称为内存屏障（Memory Barrier）。<br>具体来说，volatile的内存屏障包括以下两种：</p><ul><li>写屏障（Write Barrier）：当一个线程写入一个volatile变量时，JVM会在写操作之后插入一条写屏障指令，以确保该变量的修改能够被其他线程立即看到。</li><li>读屏障（Read Barrier）：当一个线程读取一个volatile变量时，JVM会在读操作之前插入一条读屏障指令，以确保该变量的值是最新的（即保证了前面的写操作已经完成）。</li></ul><p>使用volatile的内存屏障可以确保多个线程之间的内存可见性和有序性，避免了出现数据不一致的问题。但需要注意的是，volatile并<strong>不能保证原子性</strong>，如果需要保证操作的原子性，需要使用其他的同步机制，如synchronized关键字或者java.util.concurrent包中提供的原子类。</p></li><li><p>CAS？<br>CAS：全称 Compare and swap，即<strong>比较并交换</strong>，它是一条 <strong>CPU 同步原语</strong>。是一种硬件对并发的支持，针对多处理器操作而设计的一种特殊指令，用于<strong>管理对共享数据的并发访问</strong>。<br>CAS 包含了 3 个操作数：旧的预期值 A（刚开始读的），需要读写的内存值 V（修改前一刻读的），要修改的更新值 B。只有当V&#x3D;A时才修改（说明没有被动过）。如果不等，重新进行比较和更新。</p><p>ABA问题：并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况。此时A已经非彼A，数据即使成功修改，也可能有问题。可以通过<strong>AtomicStampedReference</strong>解决ABA问题，它，一个带有标记的原子引用类，通过控制变量值的版本来保证CAS的正确性。</p></li><li><p>ThreadLocal？<br>ThreadLocal，即线程本地变量。如果创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到<strong>线程隔离</strong>的作用，避免了线程安全问题。</p><p>实现原理：通过一个<strong>ThreadLocalMap</strong>来实现的，每个线程都有一个ThreadLocalMap实例。在ThreadLocalMap中，每个ThreadLocal对象都有一个对应的Entry对象，Entry对象中保存了该线程对应的变量值。每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。</p></li><li><p>ThreadLocal内存泄漏问题？<br> ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，⽽ value 是强引⽤。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。 假如我们不做任何措施的话，value 永远⽆法被GC 回收，这个时候就可能会产⽣内存泄露。</p><p>如何解决内存泄漏问题？<br>使用完ThreadLocal后，及时调用remove()方法释放内存空间。</p></li><li><p>AQS是什么？<br>AQS全称是AbstractQueuedSynchronizer，是Java并发包中用于<strong>实现锁、同步器等高级同步功能的基础框架</strong>。它提供了一种基于FIFO等待队列的锁获取与释放的机制，同时也提供了一些方法供开发者自定义同步器。</p><p>AQS的原理可以简单概括为以下三个方面：</p><ul><li>状态管理：AQS通过维护一个状态变量来管理同步器的状态，状态可以是任意Java数据类型，如int、boolean等，通常表示锁的持有次数或资源的数量等。</li><li>等待队列：AQS通过维护一个等待队列来管理处于阻塞状态的线程，等待队列是一个FIFO队列，由多个Node节点构成，Node节点保存了线程的引用和状态等信息。</li><li>CAS操作：AQS使用CAS操作来保证并发安全性，CAS操作可以在不使用锁的情况下，实现对内存中的值的原子操作。AQS中使用CAS操作来实现锁的获取和释放操作，在获取锁时，它会使用CAS操作尝试获取锁，如果CAS操作失败，线程会被阻塞，并加入到等待队列中，等待其他线程释放锁并通知它，在释放锁时，它会使用CAS操作更新锁的状态，并从等待队列中唤醒一个或多个线程，使它们尝试重新获取锁。</li></ul></li><li><p>线程池核心参数？</p><ul><li>corePoolSize：核心线程大小。</li><li>maximumPoolSize ：表示线程池中允许存在的最大线程数量。</li><li>keepAliveTime：线程空闲时间，表示空闲线程的存活时间。</li><li>unit：线程空闲时间的单位。</li><li>workQueue：任务队列，用于保存尚未执行的任务。</li><li>threadFactory：线程工厂，用于创建新的线程。</li><li>handler：拒绝策略。</li></ul></li><li><p>为什么使用线程池？<br><strong>降低资源消耗。</strong> 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br><strong>提高响应速度。</strong> 当任务到达时，任务可以不需要的等到线程创建就能立即执行。<br><strong>提高线程的可管理性。</strong>可以进行统一的分配，调优和监控。</p></li><li><p>线程池的拒绝策略有哪些？</p><ul><li>AbortPolicy：<strong>默认饱和策略</strong>。直接丢弃任务，并抛出RejectedExecutionException异常。</li><li>DiscardPolicy：直接丢弃任务，什么都不做。</li><li>CallerRunsPolicy：线程池之外的线程直接调用run方法执行。</li><li>DiscardOldestPolicy：将workQueue队首任务丢弃，将最新线程任务重新加入队列执行。</li></ul></li><li><p>线程池的工作方式？</p><ol><li>初始化线程池：在创建线程池时，需要设置线程池的核心线程数、最大线程数、线程空闲时间、任务队列等参数，并初始化线程池中的线程。</li><li>提交任务：将需要执行的任务提交给线程池，线程池会根据一定的策略将任务分配给空闲线程或新建线程执行。</li><li>执行任务：线程池中的线程会从任务队列中获取任务并执行，执行完成后会返回线程池并等待下一次任务。</li><li>管理线程：线程池会根据线程使用情况动态调整线程池中的线程数量，以保证线程池中的线程数量始终处于一个合适的范围内。</li><li>销毁线程池：在程序结束时，需要调用线程池的shutdown()方法来销毁线程池，同时释放线程池中的线程资源。</li></ol></li><li><p>常用的线程池？</p><ul><li>FixedThreadPool：线程池中的线程数量固定不变，适用于执行时间较短的任务，可以避免线程的频繁创建和销毁，提高了系统的性能。</li><li>CachedThreadPool：线程池中的线程数量不固定，适用于执行时间较短的任务，当任务量增加时，会动态增加线程数量；当任务减少时，会动态减少线程数量。</li><li>ScheduledThreadPool：线程池中的线程数量固定不变，适用于需要定时执行任务的场景，比如定时发送邮件、定时备份数据等。</li><li>SingleThreadPool：线程池中只有一个线程，适用于需要顺序执行任务的场景，确保所有任务按照指定的顺序执行。</li><li>WorkStealingPool：Java8 新增的线程池，线程数量可以动态调整，每个线程都有自己的任务队列，可以从其他线程的队列中“窃取”任务，提高线程的利用率。</li></ul><p>怎么创建线程池？<br>方式一：通过<strong>ThreadPoolExecutor</strong>构造函数来创建（推荐）<br>方式二：通过 Executor 框架的工具类 Executors 来创建。</p></li><li><p>线程池常用的阻塞队列有哪些？</p><ul><li><strong>LinkedBlockingQueue</strong> ： FixedThreadPool 和 SingleThreadExector 使用，容量为 Integer.MAX_VALUE ，可以认为是无界队列。由于 FixedThreadPool 线程池的线程数是固定的，所以没有办法增加特别多的线程来处理任务，这时就需要 LinkedBlockingQueue 这样一个没有容量限制的阻塞队列来存放任务。</li><li><strong>SynchronousQueue</strong>：CachedThreadPool使用。</li><li><strong>DelayedWorkQueue</strong>： ScheduledThreadPool 和 SingleThreadScheduledExecutor使用。</li></ul></li></ol><h2 id="三、JVM"><a href="#三、JVM" class="headerlink" title="三、JVM"></a>三、JVM</h2><ol><li><p>JVM内存区域？</p><ul><li>程序计数器：<strong>线程私有</strong>的，是一块很小的内存空间，作为当前线程的行号指示器，用于记录当前虚拟机正在执行的线程指令地址；</li><li>虚拟机栈：<strong>线程私有</strong>的，每个方法执行的时候都会创建一个栈帧，用于存储<strong>局部变量表</strong>、<strong>操作数</strong>、<strong>动态链接</strong>和<strong>方法返回</strong>等信息，当线程请求的栈深度超过了虚拟机允许的最大深度时，就会抛出StackOverFlowError；</li><li>本地方法栈：<strong>线程私有</strong>的，保存的是<strong>native方法</strong>的信息，当一个jvm创建的线程调用native方法后，jvm不会在虚拟机栈中为该线程创建栈帧，而是简单的动态链接并直接调用该方法；</li><li>堆：java堆是所有线程共享的一块内存，几乎所有<strong>对象的实例</strong>和<strong>数组</strong>都要在堆上分配内存，因此该区域经常发生垃圾回收的操作；</li><li>方法区：存放<strong>已被加载的类信息、常量、静态变量</strong>、<strong>即时编译器编译后的代码数据</strong>。即永久代，在jdk1.8中不存在方法区了，被元数据区替代了，原方法区被分成两部分；1：加载的类信息，2：运行时常量池；加载的类信息被保存在元数据区中，运行时常量池保存在堆中；</li></ul></li><li><p>垃圾回收的算法？</p><ul><li><strong>标记清楚法</strong>：利用可达性去遍历内存，把存活对象和垃圾对象进行标记；在遍历一遍，将所有标记的对象回收掉； 特点：效率不行，标记和清除的效率都不高；标记和清除后会产生大量的<strong>不连续的空间碎片</strong>，可能会导致之后程序运行的时候需分配大对象而找不到连续分片而不得不触发一次GC；</li><li><strong>标记整理法</strong>：利用可达性去遍历内存，把存活对象和垃圾对象进行标记； 将所有的存活的对象向一段移动，将端边界以外的对象都回收掉； 特点：适用于存活对象多，垃圾少的情况；需要整理的过程，无空间碎片产生；标记整理法需要将所有存活的对象复制到一段新的内存区域中，这会产生<strong>额外的开销</strong>，并且可能会导致频繁的内存分配和释放操作。</li><li><strong>复制算法</strong>：将内存按照容量大小分为大小相等的两块，每次只使用一块，当一块使用完了，就将还存活的对象移到另一块上，然后在把使用过的内存空间移除； 特点：不会产生空间碎片；<strong>内存使用率极低</strong>；</li><li><strong>分代收集法</strong>：根据内存对象的存活周期不同，将内存划分成几块，java虚拟机一般将内存分成新生代和老生代，在新生代中，有大量对象死去和少量对象存活，所以采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集；老年代中因为对象的存活率极高，没有额外的空间对他进行分配担保，所以采用标记清理或者标记整理算法进行回收；</li></ul></li><li><p>如何判断对象是否存活？</p><ul><li><strong>引用计数法</strong>： 给每一个对象设置一个引用计数器，当有一个地方引用该对象的时候，引用计数器就+1，引用失效时，引用计数器就-1；当引用计数器为0的时候，就说明这个对象没有被引用，也就是垃圾对象，等待回收； 缺点：无法解决循环引用的问题，当A引用B，B也引用A的时候，此时AB对象的引用都不为0，此时也就无法垃圾回收，所以一般主流虚拟机都不采用这个方法；</li><li><strong>可达性分析法</strong>： 从一个被称为GC Roots的对象向下搜索，如果一个对象到GC Roots没有任何引用链相连接时，说明此对象不可用，在java中可以作为GC Roots的对象有以下几种：<ul><li>虚拟机栈中引用的对象</li><li>方法区类静态属性引用的变量</li><li>方法区常量池引用的对象</li><li>本地方法栈JNI引用的对象</li></ul></li></ul></li><li><p>CMS垃圾回收器？<br>一种以低停顿时间为目标的垃圾回收器。</p><p>初始标记阶段：该阶段是 <strong>STW</strong> 阶段，用于标记 GC Root 能直接关联到的对象，标记完成后，GC 线程会立即停止所有应用程序的线程，进入下一阶段。</p><p>并发标记阶段：该阶段与应用程序线程并发执行，标记所有 GC Root 可达的对象，并将这些对象标记为“存活”。</p><p>重新标记阶段：该阶段是 <strong>STW</strong> 阶段，用于标记在并发标记阶段中因应用程序线程的执行而产生的新对象，以及在并发标记阶段中发生变化的对象。标记完成后，GC 线程会立即停止所有应用程序的线程，进入下一阶段。</p><p>并发清除阶段：该阶段与应用程序线程并发执行，对未被标记为“存活”的对象进行清除。</p><p>问题：无法清理浮动垃圾，内存碎片问题（CMS是一款基于“标记-清除”算法实现的回收器）。</p></li><li><p>G1回收器？<br>通过将整个堆空间划分为多个 Region 区域，并采用增量式回收方式</p><p>初始标记：标记GC ROOT能关联到的对象，需要<strong>STW</strong>(停顿线程）；</p><p>并发标记：从GCRoots的直接关联对象开始遍历整个对象图的过程，扫描完成后还会重新处理并发标记过程中产生变动的对象；</p><p>最终标记：短暂暂停用户线程，再处理一次，需要<strong>STW</strong>；</p><p>筛选回收：更新Region的统计数据，对每个Region的回收价值和成本排序，根据用户设置的停顿时间制定回收计划。再把需要回收的Region中存活对象复制到空的Region，同时清理旧的Region。需要<strong>STW</strong>。</p></li><li><p>类加载？类加载过程？<br>类加载：虚拟机把描述类的数据加载到内存里面，并对数据进行校验、解析和初始化，最终变成可以被虚拟机直接使用的class对象；<br>过程：</p><ul><li>加载，加载分为三步： 1、通过类的全限定性类名获取该类的二进制流； 2、将该二进制流的静态存储结构转为方法区的运行时数据结构； 3、在堆中为该类生成一个class对象；</li><li>验证：验证该class文件中的字节流信息复合虚拟机的要求，不会威胁到jvm的安全；</li><li>准备：为class对象的静态变量分配内存，初始化其初始值；</li><li>解析：该阶段主要完成符号引用转化成直接引用；</li><li>初始化：到了初始化阶段，才开始执行类中定义的java代码；初始化阶段是调用类构造器的过程；</li></ul></li><li><p>什么是双亲委派模型？<br>双亲委派模型是一种类加载机制。当一个类加载器需要加载一个类时，它会先向其父类加载器发起请求。如果父类加载器可以加载该类，则直接返回Class对象。如果父类加载器无法加载该类，则将任务再次委派给它的父类加载器，一直到顶层的启动类加载器，如果仍然无法完成加载任务，那么这个类加载器会尝试自己去加载这个类。</p><p>好处：使用双亲委派的好处是，保证同一个类在不同的类加载器中只会被加载一次，避免了重复加载，同时也可以保证类的安全性。</p></li><li><p>JVM调优命令？</p><ul><li>jps：查看程序对应的 PID。</li><li>jmap：查找线程内存使用情况。</li><li>jstack：查看线程情况。</li><li>jstat：调优重点，查看 GC 情况。用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</li></ul></li></ol><h2 id="四、操作系统"><a href="#四、操作系统" class="headerlink" title="四、操作系统"></a>四、操作系统</h2><ol><li><p>协程？<br>协程是一种用户态的轻量级线程，它由程序员控制，可以在同一线程中实现多个协程的切换。协程之间的切换比线程之间的切换更快，因为协程的切换只需要保存少量的状态信息，不需要切换上下文。<br>协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态中执行）。<br>线程进程都是同步机制，而协程则是异步机制；<br>线程是抢占式，而协程是非抢占式的。<br>协程能保留上一次调用的状态，每次重入时，就相当于进入上一次调用的状态；</p></li><li><p>进程间通信方式有哪些？</p><ul><li><strong>管道</strong>：半双工的通信，数据只能单向流动，只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。速度慢，容量有限；<strong>匿名管道</strong>：单向的，只能在有亲缘关系的进程间通信；<strong>命名管道</strong>：以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li><li><strong>消息队列</strong>：消息队列是一种在进程间传递数据的方式，它通过消息缓冲区实现数据的交换。不同进程之间可以通过消息队列发送和接收消息，并且可以设置优先级等参数。</li><li><strong>信号量</strong>：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。因此，主要作为进程之间和线程之间的同步手段。</li><li><strong>共享内存</strong>：共享内存是一种最快的进程间通信方式，它可以实现进程之间的数据共享。不同进程可以访问同一个共享内存区域，并且可以通过信号量等机制进行同步和互斥。</li><li><strong>套接字</strong>：套接字是一种在网络上进行进程间通信的方式，它可以在不同的机器和进程之间传递数据。套接字可以实现不同进程之间的数据传输和通信，是网络编程中常用的通信方式。</li></ul></li><li><p>死锁产生的四个必要条件？</p><ul><li>互斥条件：一个资源一次只能被一个进程使用</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li><li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li><li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li></ul></li><li><p>什么是虚拟内存？<br>虚拟内存就是让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。虚拟内存使用部分加载的技术，让一个进程或者资源的某些页面加载进内存，从而能够加载更多的进程，甚至能加载比内存大的进程，这样看起来好像内存变大了，这部分内存其实包含了磁盘或者硬盘，并且就叫做虚拟内存。</p><p>实现方式：请求分页存储管理，请求分段存储管理，请求段页式存储管理。</p></li><li><p>IO多路复用？<br>O多路复用是一种高效的IO模型，可以同时监视多个IO流，当有数据到来时，系统可以通知相应的进程或线程进行处理。常见的IO多路复用技术包括<strong>select</strong>、<strong>poll</strong>、<strong>epoll</strong>等。</p><p>IO多路复用的实现原理是利用操作系统内核提供的select、poll、epoll等系统调用，将多个IO流的状态（读&#x2F;写&#x2F;异常）注册到一个等待队列中，然后进入等待状态，直到有数据到来或者超时。当有数据到来时，操作系统会通知应用程序哪些IO流已经准备好，然后应用程序可以进行相应的读写操作。</p></li><li><p>select、poll 和 epoll 之间的区别?</p><ul><li><p>处理的最大文件描述符数量不同： select和poll的最大文件描述符数量都是固定的，通常为1024，而epoll没有这个限制，可以支持大量的文件描述符。</p></li><li><p>检查I&#x2F;O流状态的效率不同：select和poll在处理大量的文件描述符时，效率会随着文件描述符数量的增加而下降，因为每次系统调用都要检查所有的文件描述符。而epoll使用了一种基于事件驱动的机制，内核里维护了一个「<strong>链表</strong>」来记录就绪事件。当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，这样可以大大减少系统调用的次数，提高效率。</p></li><li><p>对于内核空间和用户空间的交互方式不同：select和poll每次系统调用都需要将所有的文件描述符集合从用户空间复制到内核空间，这样会带来一定的开销。而epoll 在内核里使用「<strong>红黑树</strong>」来关注进程所有待检测的 Socket.</p></li><li><p>支持的I&#x2F;O事件类型不同： select和poll只支持可读、可写和异常事件的监视，而epoll支持这三种事件以及ET模式和LT模式（边缘触发和水平触发模式），ET模式只有在状态发生变化时才会通知用户程序，而LT模式则是在有数据可读时就会通知。</p></li></ul><p>总体而言，epoll相对于select和poll具有更高的性能和更灵活的可扩展性，能够处理大量的文件描述符并且支持多种I&#x2F;O事件类型，因此在高并发的网络编程中被广泛应用。</p></li></ol><h2 id="五、计算机网络"><a href="#五、计算机网络" class="headerlink" title="五、计算机网络"></a>五、计算机网络</h2><ol><li><p>TCP和UDP的区别？</p><ul><li>TCP是面向连接的可靠传输，UDP是无连接不可靠传输</li><li>TCP有序，UDP无序</li><li>TCP传输速度慢，UDP快</li><li>UDP支持一对一，一对多，多对一和多对多交互通信，TCP只能是一对一通信</li><li>UDP面向报文传输，TCP面向字节流传输</li></ul><p>应用场景：<br>TCP：HTTP、FTP、SMTP、TELNET</p><p>UDP：DNS、TFTP、SNMP、NFS</p></li><li><p>TCP三次握手？<br>① 第一次握手：客户端请求建立连接，向服务端发送一个<strong>同步报文</strong>（SYN&#x3D;1），同时选择一个随机数 seq &#x3D; x 作为<strong>初始序列号</strong>，并进入SYN_SENT状态，等待服务器确认。<br>② 第二次握手：服务端收到连接请求报文后，如果同意建立连接，则向客户端发送<strong>同步确认报文</strong>（SYN&#x3D;1，ACK&#x3D;1），确认号为 ack &#x3D; x + 1，同时选择一个随机数 seq &#x3D; y 作为初始序列号，此时服务器进入SYN_RECV状态。<br>③ 第三次握手：客户端收到服务端的确认后，向服务端发送一个<strong>确认报文</strong>（ACK&#x3D;1），确认号为 ack &#x3D; y + 1，序列号为 seq &#x3D; x + 1，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p><p><strong>注意</strong>：第三次握手是可以携带数据的，前两次握手是不可以携带数据的</p></li><li><p>TCP为什么需要三次握手，而不是两次？</p><ul><li>防止已过期的连接请求报文突然又传送到服务器，因而产生错误和资源浪费；</li><li>三次握手才能让双方均确认自己和对方的发送和接收能力都正常：第一次服务端确定客户端发送和服务端接受正常，第二次客户端确定客户端发送和接受正常以及服务端发送和接收正常，第三次服务端确定自己发送和接收正常以及客户端发送和接收正常。</li><li>同步双方初始序列号。去除重复的数据，根据数据包的序列号按序接收。</li></ul></li><li><p>TCP 的四次挥手过程？<br>① 第一次挥手：客户端向服务端发送连接释放报文（FIN&#x3D;1，ACK&#x3D;1），初始序列号seq &#x3D; m,主动关闭连接，同时等待服务端的确认。<br>② 第二次挥手：服务端收到连接释放报文后，立即发出确认报文（ACK&#x3D;1），序列号 seq &#x3D; k，确认号 ack &#x3D; m + 1。<br>③ 第三次挥手：服务端向客户端发送连接释放报文（FIN&#x3D;1，ACK&#x3D;1），序列号 seq &#x3D; w,主动关闭连接，同时等待服务端的确认。<br>④ 第四次挥手：客户端收到服务端的连接释放报文后，立即发出确认报文（ACK&#x3D;1），序列号 seq &#x3D; m + 1，确认号为 ack &#x3D; w + 1。此时，客户端就进入了 TIME-WAIT 状态。注意此时客户端到 TCP 连接还没有释放，必须经过 <strong>2*MSL</strong>（最长报文段寿命）的时间后，才进入 CLOSED 状态。</p></li><li><p>为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回 ACK 报文段。接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 FIN 报文，表示数据已经发送完毕，请求关闭连接。</p></li><li><p>TCP四次挥手后，为什么要time_wait 2MSL？等1MSL为啥不可以？</p><p>确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接。第四次挥手时，客户端第四次挥手的 ACK 报文不一定会到达服务端。服务端会超时重传 FIN&#x2F;ACK 报文，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到 FIN&#x2F;ACK 报文的确认，就无法正常断开连接。MSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL 超时 + 服务端 FIN 报文 1MSL 传输」</p><p>防止已失效的连接请求报文段出现在之后的连接中。</p></li><li><p>TCP如何保证传输可靠性？</p><ul><li>建立连接：通过三次握手建立连接，保证连接实体真实存在；</li><li>序列号机制：保证数据是按序、完整到达；</li><li>数据校验：TCP报文头有校验和，用于校验报文是否损坏；</li><li>超时重传：如果发送一直收不到应答，可能是发送数据丢失，也可能是应答丢失，发送方再等待一段时间之后都会进行重传。</li><li>流量控制：当接收方来不及处理发送方的数据，能通过<strong>滑动窗口</strong>，提示发送方降低发送的速率，防止包丢失。</li><li>拥塞控制：网络层拥堵造成的拥塞，包括<strong>慢启动</strong>，<strong>拥塞避免</strong>，<strong>快速重传</strong>三种机制</li></ul></li><li><p>HTTP1.0和HTTP1.1的区别?</p><ul><li>HTTP1.0使用短连接，HTTP1.1使用<strong>长连接</strong>，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。</li><li>缓存处理：HTTP 1.1中缓存处理更加优化，增加了缓存控制机制，如Cache-Control、If-Modified-Since等，使得缓存机制更加灵活，有助于提高网络传输效率。</li><li>错误处理：HTTP 1.1中增加了更多的状态码，使得错误处理更加细致，例如401表示未授权，403表示禁止访问等。</li><li>带宽优化：HTTP 1.1支持<strong>断点续传</strong>，可以在传输过程中动态调整数据块的大小，使得带宽利用更加高效。</li></ul></li><li><p>HTTP1.1和HTTP2.0和区别？</p><ul><li>新的传输格式：2.0使用<strong>二进制</strong>格式报文，1.1依然使用基于文本格式。</li><li>多路复用：HTTP 2.0支持<strong>多路复用</strong>，即可以在单个连接上同时传输多个请求和响应。这可以避免HTTP 1.1中的队头阻塞问题，提高了网络传输效率。</li><li>头部压缩：HTTP 2.0引入了<strong>头部压缩机制</strong>，可以将请求和响应的头部信息压缩，减少了网络传输的开销，提高了网络传输效率。</li><li>服务器推送：HTTP 2.0支持服务器推送，即<strong>服务器可以主动将客户端需要的资源推送到客户端</strong>，减少了客户端的请求次数，提高了页面加载速度。</li></ul></li><li><p>HTTP3？<br>HTTP&#x2F;3是一种基于<strong>QUIC协议</strong>的新一代HTTP协议，旨在提高网络传输效率和安全性。它相对于HTTP&#x2F;1.1和HTTP&#x2F;2.0有以下特点：</p><ul><li>基于UDP协议：HTTP&#x2F;3是基于QUIC协议的，而QUIC协议是基于UDP协议的。与TCP协议相比，UDP协议的连接建立速度更快，且支持多路复用和流量控制，同时减少了TCP协议的队头阻塞问题。</li><li>快速连接建立：HTTP&#x2F;3使用了0-RTT（零往返时间）连接建立，可以在不需要等待握手过程的情况下建立连接，从而减少了网络延迟。</li><li>快速恢复：HTTP&#x2F;3支持快速恢复机制，可以在网络丢失数据包时更快地进行恢复。</li></ul></li><li><p>TCP的拥塞控制？<br>TCP的拥塞控制是一种在TCP协议中用于控制网络拥塞的机制。当网络发生拥塞时，拥塞控制机制可以自适应地降低发送方的数据传输速率，以避免网络拥塞问题的发生。</p><ul><li><strong>慢启动</strong>：在TCP建立连接时，发送方会以较慢的速度发送数据，每经过一个往返时间，就将发送窗口的大小翻倍，直到达到一个阈值。</li><li><strong>拥塞避免</strong>：在发送方的数据发送速度达到一个阈值时，将会进入拥塞避免状态。此时，每经过一个往返时间，发送方将仅仅增加发送窗口的大小1个单位，以避免网络拥塞的问题。</li><li><strong>快速重传</strong>：当发送方接收到接收方的重复确认消息时，说明可能发生了数据包的丢失。发送方将快速重传这个丢失的数据包，以避免等待超时，从而降低网络拥塞的程度。</li><li><strong>快速恢复</strong>：当发送方接收到接收方的重复确认消息时，说明可能发生了数据包的丢失。发送方将立即进入快速恢复状态，将发送<strong>窗口的大小减半</strong>，并发送丢失数据包之后的所有数据包，以提高数据传输的速度。</li></ul></li><li><p>状态码301和302区别？<br>301适合<strong>永久重定向</strong>，表示所请求的资源已经永久地转移到新的位置。302用来做<strong>临时重定向</strong>，表示所请求的资源临时地转移到新的位置。</p></li><li><p>HTTP的常见状态码？</p><ul><li>1xx（信息性状态码）：表示服务器已经接收到了客户端的请求，并且正在处理中，比如100（Continue）表示客户端应该继续发送请求。</li><li>2xx（成功状态码）：表示服务器已经成功处理了请求，比如200（OK）表示请求成功，201（Created）表示请求成功并且服务器创建了新的资源。</li><li>3xx（重定向状态码）：表示需要客户端进一步的操作才能完成请求，比如301（Moved Permanently）表示请求的资源已经永久移动到新的URL，需要客户端更新书签。</li><li>4xx（客户端错误状态码）：表示客户端发送的请求有问题，比如404（Not Found）表示请求的资源不存在，400（Bad Request）表示请求格式有误。</li><li>5xx（服务器错误状态码）：表示服务器处理请求时发生了错误，比如500（Internal Server Error）表示服务器内部错误，无法完成请求。</li></ul></li><li><p>GET和POST请求的区别？</p><ul><li>参数传递方式：GET请求通过URL参数传递参数，而POST请求通过请求体传递参数。</li><li>安全性：GET请求的参数暴露在URL中，可能被缓存或者记录在日志中，安全性较低；而POST请求的参数在请求体中，相对安全一些。</li><li>请求的数据大小：GET请求由于参数在URL中，所以传递的数据大小有限制，一般不超过2KB，而POST请求则没有这个限制。</li><li>GET和POST最大的区别主要是<strong>GET请求是幂等性的</strong>，POST请求不是，这个是它们<strong>本质区别</strong>。也就是说GET多次请求得到的结果都是一样的，不会对服务器造成影响，因此可以被缓存；而POST请求一般不会被缓存，因为会对服务器造成副作用，如重复提交表单等。</li></ul></li><li><p>HTTP和HTTPS的区别？</p><table><thead><tr><th align="center"></th><th align="center">HTTP</th><th align="center">HTTPS</th></tr></thead><tbody><tr><td align="center">安全性</td><td align="center">明文传输，不安全</td><td align="center">采用SSL&#x2F;TSL加密技术，安全</td></tr><tr><td align="center">端口号</td><td align="center">80</td><td align="center">443</td></tr><tr><td align="center">证书</td><td align="center">不需要</td><td align="center">服务端需要向客户端提供数字证书，证书中包含了服务器的公钥，<br />客户端会根据证书来验证服务器的身份是否合法，可以防止中间人攻击。</td></tr><tr><td align="center">协议</td><td align="center">TCP</td><td align="center">TCP，SSL（运行在TCP之上）</td></tr><tr><td align="center">资源消耗、性能</td><td align="center">较少</td><td align="center">加密处理，资源消耗更多，握手时间更长</td></tr></tbody></table></li><li><p>HTTTPS加密流程？<br>① 客户端向服务器发起HTTPS请求。<br>② 服务器向客户端返回数字证书，证书中包含了服务器的公钥。<br>③ 客户端会验证服务器返回的证书是否合法。<br>④ 客户端生成一个随机的对称加密密钥，用于对数据进行加密和解密。<br>⑤ 客户端使用服务器的公钥对生成的随机密钥进行加密，然后将加密后的密钥发送给服务器。<br>⑥ 服务器使用自己的私钥对客户端发送的加密后的密钥进行解密，得到随机密钥。<br>⑦ 客户端和服务器使用随机密钥对通信数据进行加密和解密，保证了数据在传输过程中的安全性。</p></li><li><p>浏览器中的一个网址如何去返回给你界面，在网络中经历了什么？</p><ul><li>DNS域名解析：将域名解析为对应的IP地址</li><li>浏览器通过IP地址和端口号建立与服务器的TCP连接，进行数据传输。</li><li>建立TCP连接后，浏览器会向服务器发送HTTP请求</li><li>服务器处理请求并返回响应：服务器接收到请求后，会根据请求内容，处理请求并生成响应。</li><li>服务器返回响应后，浏览器会解析响应，并呈现给用户。</li></ul></li><li><p>DNS的域名解析过程？</p><ul><li>浏览器首先会检查<strong>本地缓存</strong>中是否已经有该域名的解析结果。如果有，就直接使用本地缓存中的IP地址，不需要进行后续的DNS解析。</li><li>如果本地缓存中没有该域名的解析结果，浏览器会向<strong>本地DNS服务器</strong>发起请求，要求解析该域名的IP地址。</li><li>本地DNS服务器会先检查自己的缓存，如果没有，就向<strong>根DNS服务器</strong>查询。</li><li>根DNS服务器会返回一个<strong>顶级域DNS服务器</strong>的IP地址给本地DNS服务器。</li><li>本地DNS服务器再向顶级域DNS服务器查询，顶级域DNS服务器会返回一个<strong>权威DNS服务器</strong>的IP地址给本地DNS服务器。</li><li>本地DNS服务器再向权威DNS服务器查询，权威DNS服务器会返回该域名对应的IP地址给本地DNS服务器，并告知其可以缓存一段时间。</li><li>本地DNS服务器将收到的IP地址返回给浏览器，并将其<strong>缓存</strong>起来以备后用。</li><li>浏览器收到IP地址后，就可以与目标主机建立连接并交换数据。</li></ul></li><li><p>拆包粘包？<br>粘包是指<strong>多个数据块被组合成一个大的数据包发送到接收方</strong>，而接收方只能一次性接收到所有数据块，导致接收方无法区分多个数据块之间的边界，从而导致数据的解析和处理出现问题。</p><p>拆包是指<strong>一个数据块被分成多个小的数据包发送到接收方</strong>，接收方需要将这些小的数据包组合成一个完整的数据块，但由于小数据包之间可能存在网络延迟或丢失，从而导致接收方在组合数据块时缺少部分数据或者将多个数据块错误组合。</p></li><li><p>造成粘包和拆包的原因？</p><ul><li><strong>发送方发送数据速度过快</strong>，接收方没有及时接收到数据，从而导致多个数据包被组合成一个大的数据包。</li><li><strong>接收方处理数据速度过慢</strong>，导致接收方在处理完一个数据包后还没有及时处理下一个数据包，从而多个数据包被组合成一个大的数据包。</li></ul><p>解决方式：</p><ul><li><strong>消息定长</strong>：发送方在发送数据时，将每个数据块的大小固定为一个固定值，接收方在接收数据时，按照这个固定值进行分包，从而避免了粘包和拆包问题。</li><li>在包尾部增加回车或者空格符等特殊字符进行分割。</li><li>使用消息边界：在传输协议中，明确定义消息边界，发送方和接收方都遵循这个边界来分割数据块，从而避免了粘包和拆包问题。</li><li>使用应用层协议。</li></ul></li><li><p>八种HTTP请求？</p><table><thead><tr><th align="center">GET</th><th align="center">获取资源，用于请求指定的资源</th></tr></thead><tbody><tr><td align="center">POST</td><td align="center">提交数据，用于提交指定资源的数据</td></tr><tr><td align="center">PUT</td><td align="center">更新资源，用于更新指定资源</td></tr><tr><td align="center">DELETE</td><td align="center">删除资源，用于删除指定资源</td></tr><tr><td align="center">HEAD</td><td align="center">获取报头，用于获取与GET请求相同的报头，但不返回正文部分</td></tr><tr><td align="center">OPTIONS</td><td align="center">获取支持的请求方式，用于获取服务器支持的请求方法</td></tr><tr><td align="center">CONNECT</td><td align="center">建立连接隧道，用于建立与资源的双向连接</td></tr><tr><td align="center">TRACE</td><td align="center">跟踪路径，用于将服务器收到的请求信息返回给客户端，用于测试和调试</td></tr></tbody></table></li><li><p>session和cookie的区别？<br><strong>Cookie</strong>：服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。<br><strong>Session</strong>：代表着服务器和客户端一次会话的过程。用于在服务器端存储用户的状态信息。</p><p><strong>区别</strong>：</p><ul><li>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li><li>生命周期不同：Cookie有过期时间，可以设置在一段时间之后自动失效，而Session一般在用户关闭浏览器或者一定时间内没有访问后就会失效。</li><li>安全性不同：Cookie数据存储在客户端，如果被恶意获取，那么用户的信息就会暴露。而Session存储在服务端，只有服务端可以访问，相对来说更加安全。</li><li>存储容量不同：Cookie一般只能存储4K左右的数据，而Session可以存储更多的数据。</li></ul></li><li><p>输入网址，服务端这边怎么处理请求的？</p><ul><li><strong>解析请求</strong>：服务端会解析浏览器发送的请求，包括HTTP请求头部和请求正文（如果有），以确定请求的方法、URL、HTTP版本等信息。</li><li><strong>处理请求</strong>：根据请求的方法和URL，服务端会根据自己的业务逻辑进行处理，比如读取数据库、生成动态页面、获取文件等。如果请求的是静态资源，服务端会直接将该资源返回给客户端。</li><li><strong>生成响应</strong>：服务端会生成一个HTTP响应，包括HTTP响应头部和响应正文。响应头部包括响应状态码、响应类型等信息，响应正文包括服务端返回的数据（如HTML、CSS、JavaScript等）。</li><li><strong>发送响应</strong>：服务端将生成的HTTP响应发送给浏览器，浏览器会解析响应并显示相应的页面或数据。</li></ul></li><li><p>SYN泛洪？<br>SYN 泛洪是一种常见的网络攻击方式，它利用 TCP 协议中的三次握手机制来消耗网络带宽和服务器资源，从而导致服务不可用或响应变慢。<br>在 TCP 协议中，连接建立时需要进行三次握手，即客户端向服务器发送 SYN 报文，服务器收到后返回 SYN+ACK 报文，最后客户端再发送 ACK 报文，连接才能建立。而在 SYN 泛洪攻击中，攻击者向服务器发送大量的 SYN 报文，由于服务器需要维护每个连接的状态信息，因此会占用大量的服务器资源，从而导致服务器响应变慢或者崩溃。</p></li><li><p>DDoS？<br>DDoS（Distributed Denial of Service）是指分布式拒绝服务攻击，它是一种通过利用大量分布在不同地方的计算机向目标服务器发起大量请求，从而使目标服务器瘫痪的攻击方式。<br>最基本的DOS攻击过程如下：</p><ul><li>客户端向服务端发送请求链接数据包。</li><li>服务端向客户端发送确认数据包。</li><li>客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认。</li></ul><p>预防方法有：<strong>减少SYN timeout时间</strong>，<strong>限制同时打开的SYN半连接数目</strong>。</p></li><li><p>负载均衡算法有哪些？<br>多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，能互相分担负载。<br><strong>轮询法</strong>：将请求按照顺序轮流的分配到服务器上。不能发挥某些高性能服务器的优势。<br><strong>随机法</strong>：随机获取一台，和轮询类似。<br><strong>哈希法</strong>：通过ip地址哈希化来确定要选择的服务器编号。<br><strong>加权轮询</strong>：根据服务器性能不同加权。</p></li></ol><h2 id="六、MySQL"><a href="#六、MySQL" class="headerlink" title="六、MySQL"></a>六、MySQL</h2><ol><li><p>mysql执行一条select语句是如何执行的？</p><ul><li>客户端通过 <strong>TCP 连接</strong>发送连接请求到 MySQL 连接器，连接器会对该请求进行权限验证及连接资源分配。</li><li><strong>查缓存</strong>。（判断缓存是否命中时，MySQL 不会进行解析查询语句，而是直接使用 SQL 语句和客户端发送过来的其他原始信息）</li><li><strong>语法分析</strong>（SQL 语法是否写错了）。 如何把语句给到预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义。</li><li><strong>优化</strong>。是否使用索引，生成执行计划。</li><li><strong>交给执行器</strong>，将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端。</li></ul></li><li><p>MyISAM 和 InnoDB 的区别有哪些？</p><ul><li>InnoDB 支持事务，MyISAM 不支持</li><li>InnoDB 支持外键，MyISAM 不支持</li><li>InnoDB 是聚集索引，MyISAM 是非聚集索引</li><li>Innodb 不支持全文索引，而 MyISAM 支持全文索引，查询效率上 MyISAM 要高</li><li>InnoDB 不保存表的具体行数，MyISAM 用一个变量保存了整个表的行数</li><li>InnoDB 支持行级锁和表级锁,默认为行级锁，MyISAM 采用表级锁</li></ul></li><li><p>MySQL的聚蔟索引和非聚蔟索引？<br><strong>聚簇索引</strong>：将数据存储与索引放到了一块，将表的数据存放在索引的叶子节点中，一个表只能有一个聚簇索引。<br><strong>非聚簇索引</strong>：将数据存储于索引分开结构，非聚族索引的叶子节点存储的是数据位置 。<br>通常情况下， 主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要<strong>回表</strong>查询多次。当然，如果是覆盖索引的话，查一次即可（一个索引包含（覆盖）所有需要查询字段的值，被称之为”覆盖索引”）</p></li><li><p>什么是索引下推？</p><p>在联合索引遍历过程中，对联合索引中包含的字段先做判断，MySQL会在存储引擎层进行过滤，直接过滤掉不满足条件的记录，<strong>减少回表次数</strong>。</p></li><li><p>怎么查看MySQL语句有没有用到索引？<br>通过explain查看SQL语句。</p><p>select_type：查询类型，表示当前被分析的sql语句的查询的复杂度。<br>table ：表示当前访问的表的名称。<br>possible_keys：这个字段显示的是sql在查询时可能使用到的索引，但是不一定真的使用，只是一种可能。<br>key：sql执行中真正用到的索引字段。</p></li><li><p>建索引的原则有哪些？<br>最左前缀匹配原则，索引列不能参与计算，尽量的扩展索引，不要新建索引。</p></li><li><p>索引失效的场景？</p><ul><li>对索引使用左或者左右模糊匹配</li><li>对索引使用函数</li><li>对索引进行表达式计算</li><li>对索引隐式类型转换</li><li>联合索引非最左匹配</li><li>where 字句中的or，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul></li><li><p>事务的四个特性？</p><ul><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性：每提交一个事务必须先将该事务的所有日志写入到<strong>重做日志</strong>文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。</li></ul></li><li><p>四种隔离级别？</p><ul><li>Read Uncommitted（读取未提交内容）：脏读</li><li>Read Committed（读取提交内容）：</li><li>Repeatable Read（可重读）：MySQL 的<strong>默认事务隔离级别</strong>，幻读 </li><li>Serializable（可串行化）：通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。</li></ul><p>InnoDB 存储引擎在 分布式事务 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</p></li><li><p>MySQL事务的实现原理？<br>事务是基于<strong>重做日志</strong>(redo log)和<strong>回滚日志</strong>(undo log)实现的。<br>每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。<br>每当有修改事务时，还会产生 undo log，如果需要回滚，则根据 undo log 的反向语句进行逻辑操作，比如 insert 一条记录就 delete 一条记录。undo log 主要实现数据库的一致性。</p></li><li><p>binlog日志里面写了什么内容，怎么写的，什么时候写有什么用？<br>MySQL的 binlog 是记录所有<strong>数据库表结构变更</strong>（例如 CREATE、ALTER TABLE）以及<strong>表数据修改</strong>（INSERT、UPDATE、DELETE）的二进制日志。binlog 不会记录 SELECT 和 SHOW 这类操作，因为这类操作对数据本身并没有修改。<br>MySQL binlog 以事件形式记录，还包含语句所执行的消耗的时间，MySQL 的二进制日志是事务安全型的。<strong>binlog 的主要目的是复制和恢复。</strong></p></li><li><p>MVCC实现原理？<br>MVCC是一种并发控制机制，用于解决多个事务同时访问数据库时的并发问题。相比于传统的锁机制，MVCC可以在不加锁的情况下实现并发访问，提高了系统的并发能力。</p><p><strong>实现原理</strong>：InnoDB 每一行数据都有一个隐藏的<strong>回滚指针</strong>，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。</p></li><li><p>乐观锁和悲观锁？<br>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。一般会使用<strong>版本号机制</strong>或<strong>CAS</strong>算法实现。</p><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。</p></li><li><p>乐观锁实现？</p><p>使用<strong>版本号机制</strong>实现乐观锁：</p><ol><li>在数据库表中增加一个版本号字段version。</li><li>当线程读取数据时，同时取出该数据的当前版本号version。</li><li>在更新时，如果当前数据库版本号和一开始的版本号一致，则更新version+1，否则失败。</li></ol><p>使用<strong>CAS</strong>（Compare and Swap）实现乐观锁：</p><ol><li>查询出当前需要更新的数据的版本号version，并保存在一个变量old_version中。</li><li>对该数据进行修改，然后使用CAS操作将version字段更新为old_version+1。</li><li>如果CAS操作失败，说明该数据已经被其他线程修改过了，需要重新查询数据并重复上述操作。</li></ol></li><li><p>MySQL主从复制？<br>主从同步使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务器充当主服务器（master），其余的服务器充当从服务器（slave）。</p><p><strong>原理</strong>：</p><ul><li>第一步：主库master在每个事务更新数据完成之前，将数据变更记录在二进制日志binlog文件中。包括数据增删改操作，以及创建和删除数据库等操作。</li><li>从库salve开启一个I&#x2F;O Thread，从库（Slave）连接主库，将主库的二进制日志复制到自己的中继日志（Relay Log）中。</li><li>SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</li></ul></li><li><p>MySQL主从同步延时问题如何解决？</p><ul><li>优化网络连接</li><li>使用<strong>半同步复制</strong>：主库写入 binlog 日志之后，立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到至少一个从库的 ack 之后才会认为写操作完成了。</li><li>用<strong>并行复制</strong>：多个从服务器同时复制主服务器的数据。通过并行复制，可以减少从服务器上的数据与主服务器上的数据的延迟，提高同步速度。</li></ul></li></ol><h2 id="七、Redis"><a href="#七、Redis" class="headerlink" title="七、Redis"></a>七、Redis</h2><ol><li><p>Redis数据类型？</p><ul><li><strong>String</strong>：String的底层是<strong>动态字符串</strong>SDS(Simple Dynamic String)，常规key-value缓存应用。常规计数: 微博数， 粉丝数。</li><li><strong>Hash</strong>：Hash的底层是dict，hash 特别适合用于存储对象</li><li><strong>Set</strong>：无序的天然<strong>去重</strong>的集合，点赞、共同好友、共同关注什么的功能</li><li><strong>List</strong>：List的底层是链表，</li><li><strong>Zset</strong>：底层是压缩列表ziplist或者<strong>字典+跳表</strong>，是Set的可排序版，支持优先级排序，维护了一个<strong>score</strong>的参数来实现。适用于排行榜和带权重的消息队列等场景。</li><li>HyperLogLogs：统计基数的数据集合类型。百万级网页 UV 计数</li><li>Bitmap：以位为单位数组，数组中的每个单元只能存0或者1</li><li>Geospatial：用于存储地理位置信息</li></ul></li><li><p>redis快的原因？</p><ul><li><strong>内存存储</strong>：Redis是使用内存(in-memeroy)存储，没有磁盘IO上的开销。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)。</li><li><strong>单线程</strong>实现（ Redis 6.0以前）：Redis使用<strong>单个线程处理请求</strong>，避免了多个线程之间线程切换和锁资源争用的开销。注意：单线程是指的是在核心网络模型中，网络请求模块使用一个线程来处理，即一个线程处理所有网络请求。</li><li><strong>IO多路复用</strong>：Redis使用多路复用IO技术，将epoll作为I&#x2F;O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I&#x2F;O上浪费过多的时间。</li></ul></li><li><p>Redis如何保持高并发的？</p><ul><li>单线程模型：Redis采用单线程模型，通过异步I&#x2F;O和事件驱动机制来处理请求，减少了上下文切换和锁竞争等开销，从而可以支持高并发的请求。</li><li>基于内存的数据存储：Redis将数据存储在内存中，而不是磁盘中，从而大大提高了数据的读写效率。</li><li>持久化机制：Redis提供了两种持久化机制，即RDB（Redis DataBase）和AOF（Append Only File），可以将内存中的数据定期或实时保存到磁盘上，保证了数据的持久性和可靠性。</li><li>集群模式：Redis提供了集群模式，通过分片技术将数据分散到多个节点上，实现数据的分布式存储和高可用性，进一步提高了系统的并发能力和性能。</li><li>数据压缩：Redis支持对数据进行压缩，可以减少网络传输的数据量，提高数据传输的效率，从而提高并发能力。</li></ul></li><li><p>Redis是单线程的吗？<br><strong>Redis采用单线程的方式来处理网络请求和数据操作</strong>，这是因为Redis的瓶颈在于CPU的处理能力，而不是网络带宽或者磁盘I&#x2F;O等。因此采用单线程可以避免线程上下文切换等开销，提高CPU的利用率。</p><p>不过，Redis的单线程也会限制其并发能力，无法充分利用多核CPU的优势。因此，Redis引入了多线程机制来提高并发能力。多线程主要用于以下两个方面：</p><ul><li>网络I&#x2F;O多路复用：Redis可以将网络I&#x2F;O操作交给一个线程池来处理，从而避免在单线程中阻塞等待I&#x2F;O操作完成的情况，提高网络I&#x2F;O处理能力。</li><li>子进程的Fork操作：Redis在进行持久化操作时，会fork一个子进程来进行，这个子进程需要拷贝父进程的内存数据，如果数据量很大，这个操作会很耗时，而采用多线程的方式可以将这个操作并行化，提高持久化操作的效率。</li></ul><p><strong>Redis的多线程机制仅用于网络I&#x2F;O和持久化操作</strong>，Redis仍然采用单线程的方式来处理数据操作，这也是Redis能够保证数据一致性和高性能的关键之一。</p></li><li><p>Redis是怎么解决线程安全问题的？<br>edis采用单线程的方式来处理网络请求和数据操作，因此不需要考虑多线程并发访问的线程安全问题。但是，在多个客户端同时连接Redis的情况下，仍然可能存在并发访问共享数据的问题，因此Redis采用了以下几种方式来保证数据的线程安全性：</p><ul><li>原子操作：Redis提供了很多原子操作，如INCR、LPUSH、SETNX等，这些操作是不可分割的，可以保证数据的一致性。</li><li>乐观锁：Redis支持CAS（Compare And Swap）指令，通过CAS指令可以实现乐观锁机制，即先读取数据，然后在执行更新操作时检查数据是否被其他客户端修改过，如果没有修改过则更新，否则重新读取数据并重试。</li><li>分布式锁：Redis提供了分布式锁的实现方式，可以通过SETNX和EXPIRE指令来实现分布式锁的获取和释放，从而保证在分布式环境下对共享资源的互斥访问。</li></ul></li><li><p>Redis的持久化机制？<br>将Redis中的数据写入到磁盘空间中，即持久化。<br>Redis提供了两种不同的持久化方法可以将数据存储在磁盘中，一种叫快照<strong>RDB</strong>，另一种叫只追加文件<strong>AOF</strong>。</p><ul><li>RDB：RDB是Redis默认的持久化方式。是将Redis在内存中的数据周期性地保存到磁盘中。适合大规模的数据恢复，对数据完整性和一致性要求不高。</li><li>AOF：将Redis的每个<strong>写操作</strong>追加到一个日志文件中，当Redis重启时，会通过重新执行日志文件中的写操作来恢复数据。</li></ul></li><li><p>Redis过期键的删除策略？<br>Redis使用了两种策略来删除过期键，分别是<strong>定期删除</strong>和<strong>惰性删除</strong>。</p><ul><li>定期删除：Redis默认每隔一段时间就会随机抽取一些过期键并删除。这种方式简单，但可能会导致一些过期键一直存在，直到下一次定期删除时才会被删除。</li><li>惰性删除：当客户端尝试读取某个键时，Redis会检查该键是否过期，如果过期则立即删除。这种方式保证了过期键被及时删除，但也会增加读取操作的时间开销。</li></ul><p>Redis默认使用惰性删除方式，同时也会每隔一段时间启动定期删除。如果需要修改过期键的删除策略，可以通过修改配置文件或者使用命令来实现。</p></li><li><p>如何保证缓存与数据库双写时的数据一致性？<br><strong>先删除缓存，后更新数据库</strong>：删除缓存–&gt;更新数据库–&gt;sleep N毫秒–&gt;再次删除缓存（延时双删）<br><strong>先更新数据库，后删除缓存</strong>：</p></li><li><p>什么是缓存击穿？<br>缓存击穿是<strong>某个热点的key失效</strong>，大并发集中对其进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。</p><p>解决：</p><ul><li>设置热点数据的永久缓存：对于访问量较大、变化不频繁的热点数据，可以将其设置为永久缓存，避免因为缓存失效而导致的缓存击穿问题。</li><li>使用互斥锁：过互斥锁来控制读数据写缓存的线程数量</li></ul></li><li><p>什么是缓存穿透？</p><p>缓存穿透是指<strong>访问的数据在缓存和数据库中都不存在</strong>，这种情况下大量的请求会直接打到数据库上，导致数据库压力过大，影响系统性能。</p><p>解决：</p><ul><li>对空值做缓存，将无效的key存放进Redis中；</li><li>布隆过滤器：可以在缓存之前再加一个布隆过滤器，将数据库中的所有key都存储在布隆过滤器中，在查询Redis前先去布隆过滤器查询 key 是否存在，如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。</li></ul></li><li><p>布隆过滤器原理？</p><p>使用 k 个不同的哈希函数对元素进行哈希，并将得到的哈希值对一个大小为 m 的<strong>位数组</strong>进行标记，置为 1。当需要判断某个元素是否在集合中时，将该元素经过 k 个哈希函数后的结果对位数组进行查找，若所有位置均被标记，则该元素可能在集合中；否则，该元素一定不在集合中。</p></li><li><p>什么是缓存雪崩？<br>缓存雪崩是指缓存中的<strong>大量key同时失效</strong>或者缓存节点宕机，导致大量请求直接落到数据库上，引起数据库压力过大，进而影响系统性能甚至瘫痪的情况。</p><p>解决：</p><ul><li>均匀过期：设置不同的过期时间，让缓存失效的时间尽量均匀，避免相同的过期时间导致缓存雪崩。</li><li>使用多级缓存架构，将热点数据缓存在多个缓存节点上，避免单一节点的宕机导致缓存雪崩。</li><li>实现熔断机制，当数据库压力过大时，关闭缓存或降级处理，保证系统的稳定性。</li></ul></li><li><p>Redis事务的三个阶段？<br>multi 开启事务–&gt;大量指令入队–&gt;exec执行事务块内命令。<br>Redis <strong>事务的执行并不是原子性的</strong>。Redis事务中如果有某一条命令执行失败，之前的命令不会回滚，其后的命令仍然会被继续执行。</p></li><li><p>redis的主从架构和主从哨兵区别？<br><strong>Redis主从架构</strong>是将一台Redis服务器设置为主节点，其他Redis服务器设置为从节点，主节点可以进行读写操作并同步数据到从节点，从节点只能进行读操作。当主节点宕机时，从节点会选出（手动选取）一个新的主节点进行数据同步，保证服务的可用性。</p><p><strong>Redis主从哨兵</strong>则是在Redis主从架构的基础上<strong>引入哨兵节点</strong>进行监控和自动故障转移。哨兵节点会监控主节点和从节点的状态，当主节点宕机时，哨兵节点会<strong>主动选举新的 master</strong>，并将其升级为主节点。同时，哨兵节点还会更新从节点的配置，使其成为新主节点的从节点，从而实现自动故障转移。</p></li><li><p>Redis集群？<br>Redis集群是由多个Redis节点组成的<strong>分布式系统</strong>，每个节点都存储部分数据，通过节点之间的协调和通信，实现数据的分布式存储和查询。集群模式适用于大规模分布式应用场景，可以实现高可用、高性能的数据存储和读取。</p></li><li><p>Redis如何应对主从数据不一致问题？<br>自动重同步：Redis从3.2版本开始支持自动重同步(Auto Resynchronization)机制。当从节点重新连接到主节点时，如果从节点的复制偏移量(<strong>offset</strong>)比主节点的复制偏移量还要旧，那么主节点就会自动执行完整重同步，以确保从节点的数据与主节点一致。</p></li><li><p>Redis如何实现分布式锁？<br>① 使用<strong>SETNX</strong>命令尝试在Redis中设置一个键值对，其中键表示锁的名称，值为一个随机生成的唯一标识，表示锁的拥有者。<br>② 如果SETNX命令返回1，表示设置成功，当前线程获得了锁。如果SETNX命令返回0，表示设置失败，锁已经被其他线程占用。<br>③ 锁变量需要设置<strong>过期时间</strong>，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，我们在 SET 命令执行时加上 EX&#x2F;PX 选项，设置其过期时间；<br>④ 释放锁时，使用DEL命令删除Redis中的键值对，将锁释放掉。为了避免当前线程误删其他线程的锁，需要在释放锁时通过锁的唯一标识符来判断当前线程是否持有该锁，可以使用Lua脚本实现原子性的判断和删除操作。</p></li></ol><h2 id="八、Spring"><a href="#八、Spring" class="headerlink" title="八、Spring"></a>八、Spring</h2><p>1. </p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/post/ff05b5bf.html"/>
      <url>/post/ff05b5bf.html</url>
      
        <content type="html"><![CDATA[<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><p>好好学习</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
