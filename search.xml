<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面经</title>
      <link href="/post/98e6f621.html"/>
      <url>/post/98e6f621.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java开发面经"><a href="#Java开发面经" class="headerlink" title="Java开发面经"></a>Java开发面经</h1><h2 id="一、Java基础篇"><a href="#一、Java基础篇" class="headerlink" title="一、Java基础篇"></a>一、Java基础篇</h2><ol><li><p>Java中八种基本数据类型？</p><p><strong>byte</strong>（字节型8位）、<strong>short</strong>（短整型16位）、<strong>int</strong>（整型32位）、<strong>long</strong>（长整型64位）、<strong>float</strong>（单精度浮点型32位） <strong>double</strong> （双精度浮点型64位）、<strong>char</strong>（字符型16位）、<strong>boolean</strong>（布尔型1位）</p></li><li><p>static关键字？<br>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</p></li><li><p>面向对象三大特性？</p><ul><li><strong>封装</strong>。就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</li><li><strong>继承</strong>。使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。</li><li><strong>多态</strong>。它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。</li></ul></li><li><p>重载和重写的区别？</p><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。   </p><ul><li>重写发生在子类与父类之间, 重写方法<u>返回值</u>和<u>形参</u>都不能改变，与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分。<strong>即外壳不变，核心重写！</strong></li><li>重载是在一个类里面，<strong>方法名字相同，而参数不同</strong>。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。最常用的地方就是构造器的重载。</li></ul></li><li><p>抽象类和接口的区别？</p><ul><li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li><li>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。</li></ul></li><li><p>&#x3D;&#x3D;和equals的区别？<br>&#x3D;&#x3D;常用于相同的基本数据类型之间的比较（值），也可用于相同类型的对象之间的比较（比较的是两个对象的引用，也就是判断两个对象是否指向了同一块内存区域）；<br>equals方法主要用于两个对象之间，检测一个对象是否等于另一个对象。有两种情况：</p><ul><li>情况1，类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，比较的是引用。</li><li>情况2，类覆盖了equals()方法。比较内容是否相等。</li></ul></li><li><p>error和Exception的区别？<br>Exception：程序本身可以处理的异常，可以通过catch来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。<br>error：属于程序无法处理的错误 。例如，系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，一旦这类错误发生，通常应用程序会被终止。</p></li><li><p>BIO、NIO、AIO区别？</p><ul><li>BIO：同步并阻塞，在服务器中实现的模式为<strong>一个连接一个线程</strong>。也就是说，客户端有连接请求的时候，服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然这也可以通过线程池机制改善。BIO<strong>一般适用于连接数目小且固定的架构</strong>，这种方式对于服务器资源要求比较高，而且并发局限于应用中，是JDK1.4之前的唯一选择，但好在程序直观简单，易理解。</li><li>NIO：同步并非阻塞，在服务器中实现的模式为<strong>一个请求一个线程</strong>，也就是说，客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到有连接IO请求时才会启动一个线程进行处理。<strong>NIO一般适用于连接数目多且连接比较短（轻操作）的架构</strong>，并发局限于应用中，编程比较复杂，从JDK1.4开始支持。</li><li>AIO：异步并非阻塞，在服务器中实现的模式为<strong>一个有效请求一个线程</strong>，也就是说，客户端的IO请求都是通过操作系统先完成之后，再通知服务器应用去启动线程进行处理。AIO一般适用于连接数目多且连接比较长（重操作）的架构，充分调用操作系统参与并发操作，编程比较复杂，从JDK1.7开始支持。</li></ul></li><li><p>浅拷贝和深拷贝的区别？<br><strong>浅拷贝</strong>会复制对象的引用，而不是对象本身的内容。这意味着当对被复制对象进行修改时，原对象和复制对象都会受到影响。简单来说，浅拷贝只是复制了指针，而没有复制指针所指向的对象。<br><strong>深拷贝</strong>则是完全复制了对象及其内容。这意味着当对被复制对象进行修改时，原对象和复制对象是互相独立的，互不影响。深拷贝会递归地复制指针所指向的对象，直到所有的对象都被复制。</p></li><li><p>面向对象的五大基本原则？</p><ul><li><strong>单一职责原则</strong>：一个类只负责完成一个单一的职责或功能，不要把多个不同的职责耦合到一个类中，以便于提高代码的可读性、可维护性和可扩展性。</li><li><strong>开闭原则</strong>：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。即在不修改原有代码的前提下，通过扩展来增加新的功能。</li><li><strong>里氏替换原则</strong>：子类对象能够替换其父类对象，并且在不影响程序正确性的前提下，扩展父类的功能。</li><li><strong>接口隔离原则</strong>：客户端不应该被迫依赖于它们不使用的接口。</li><li><strong>依赖倒置原则</strong>：高层模块不应该依赖底层模块，它们应该都依赖于抽象接口或抽象类。即面向接口编程，而不是面向实现编程。</li></ul></li><li><p>值传递和引用传递？</p><ul><li>值传递是指传递的参数是原始数据类型或者不可变对象，传递的是<strong>参数值的副本</strong>。这样在函数内部对参数进行修改不会影响到函数外部的变量值。在 Java 中，基本数据类型和字符串都是采用值传递的方式传递参数</li><li>引用传递是指传递的参数是可变对象或者引用类型，传递的是<strong>参数引用的副本</strong>，也就是指向堆内存中的同一对象。这样在函数内部对参数进行修改会影响到函数外部的变量值。在 Java 中，数组、集合、自定义对象等都是采用引用传递的方式传递参数。</li></ul><p>需要注意的是，Java 中的引用传递并不是真正的引用传递，而是传递引用的副本。也就是说，实际传递的还是值，只不过这个值是指向对象的引用。</p></li><li><p>线程安全和不安全的集合？<br>线程安全的集合：HashTable, ConcurrentHashMap, Vector, Stack<br>线程不安全的集合：HashMap, ArrayList, LinkedList, HashSet, TreeSet, TreeMap</p></li><li><p>ArrayList和LinkedList异同？</p><ul><li>是否线程安全：ArrayList和LinkedList都不安全</li><li>底层数据结构：ArrayList底层是数组，LinkedList底层是双向循环链表</li><li>是否支持随机访问：ArrayList可以随机访问，LinkedList不能随机访问</li><li>插入和删除元素是否受位置影响：ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</li></ul></li><li><p>ArrayList和Vector的区别？</p><ul><li>Vector是线程安全的，ArrayList不是线程安全的。Vector在关键性的方法前面都加了synchronized关键字，来保证线程的安全性。如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</li><li>ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，<strong>Vector是扩展1倍</strong>，这样ArrayList就有利于节约内存空间。</li></ul></li><li><p>ArrayList的扩容机制？<br>ArrayList新建初始化时容量为0，当插入第一个元素时容量初始化为10，扩容时容量为原来的1.5倍。</p></li><li><p>Collections.sort和Arrays.sort的区别？</p><ul><li>参数类型不同：Collections.sort()方法的参数是List类型，而Arrays.sort()方法的参数是数组类型。</li><li>实现方式不同：Collections.sort()方法是对List类型进行排序的，它内部使用了<strong>归并排序</strong>（Merge Sort）算法，而Arrays.sort()方法是对数组类型进行排序的，它内部使用了<strong>快速排序</strong>（Quick Sort）算法。</li><li>排序效率不同：由于采用了不同的排序算法，因此在数据量较小的情况下，快速排序算法比归并排序算法更快，而在数据量较大的情况下，归并排序算法比快速排序算法更快。</li><li>可以排序的元素类型不同：Collections.sort()方法可以对包含任何类型的元素的List进行排序，而Arrays.sort()方法只能对基本类型和实现了Comparable接口的类进行排序。</li></ul></li><li><p>HashMap的底层数据结构是什么？</p><p>在JDK1.7 中，HashMap由“数组+链表”组成，在JDK1.8 中，由“数组+链表+红黑树”组成。当链表超过 8 且数组长度超过 64 才会转红黑树。</p></li><li><p>HashMap中key的存储索引怎么计算的？<br>首先根据key的值计算出hashcode的值，然后根据hashcode计算出hash值，最后通过hash&amp;（length-1）计算得到存储的位置。</p></li><li><p>HashMap扩容机制？<br>HashMap 在容量超过负载因子（0.75）所定义的容量之后，就会扩容。Java 里的数组是无法自动扩容的，方法是将 HashMap 的大小扩大为原来数组的<strong>两倍</strong>，并将原来的对象放入新的数组中。</p></li><li><p>HashMap为什么线程不安全？<br>多线程的put可能导致元素的丢失。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。</p><p>怎么使HashMap线程安全？<br>可以使用线程安全的 ConcurrentHashMap 类，或者在使用 HashMap 时采用同步机制，如使用 Collections.synchronizedMap 方法包装 HashMap 实例，使用对象锁来保证多线程场景下线程安全，但是这样会导致一定的性能损失。</p></li><li><p>红黑树？<br>红黑树是一种自平衡的二叉查找树，是一种高效的查找树。红黑树具有良好的效率，它可在 O(logN) 时间内完成查找、增加、删除等操作。</p><p>每个节点或者是红色的，或者是黑色的。根节点是黑色的。每个叶节点（NIL节点，空节点）是黑色的。如果一个节点是红色的，则它的子节点必须是黑色的。从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。通过这些特点，红黑树可以保证树的高度是平衡的，从而提高了树的搜索、插入、删除等操作的效率。</p><p>红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。而平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。</p></li><li><p>ConcurrentHashMap底层数据结构？<br>JDK1.7之前是<strong>分段数组+链表</strong>，JDK1.8之后和HashMap一样，为<strong>数组+链表+红黑树</strong>。<br>JDK1.7之前使用分段锁，JDK1.8抛弃了原有的 Segment 分段锁，采用CAS + synchronized实现更加低粒度的锁，在链表头结点或红黑树根节点加锁。</p></li></ol><h2 id="二、Java并发"><a href="#二、Java并发" class="headerlink" title="二、Java并发"></a>二、Java并发</h2><ol><li><p>进程和线程的区别？</p><ul><li>进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。</li><li>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</li><li>一个进程内有多个线程，线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li><li>同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的。</li><li>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li></ul></li><li><p>创建线程的三种方式？</p><ul><li>实现Runnable接口：重写run()方法，没有返回值</li><li>实现Callable接口：重写call()方法，有返回值</li><li>继承Thread类</li></ul></li><li><p>sleep()和wait()方法的异同？<br>sleep()：是Thread类的静态方法，当前线程将睡眠n毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进入可运行状态，等待CPU的到来。睡眠不释放锁（如果有的话）。<br>wait()：是Object的方法，必须与synchronized关键字一起使用，线程进入阻塞状态，当notify或者notifyall被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，会释放互斥锁。</p></li><li><p>Thread类中yield方法的作用？<br>yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。</p></li><li><p>volatile的使用及原理？<br>volatile<strong>保证变量对所有线程的可见性</strong>：当volatile变量被修改，新值对所有线程会立即更新。或者理解为多线程环境下使用volatile修饰的变量的值一定是最新的。</p><p><strong>原理</strong>：volatile 通过编译器在生成字节码时，在指令序列中添加” 内存屏障 “来禁止指令重排序的。</p><p>volatile的<strong>内存屏障</strong>指的是在使用volatile变量时，JVM需要插入一些特殊的指令，以<strong>确保多个线程之间的内存可见性和有序性</strong>。这些指令通常被称为内存屏障（Memory Barrier）。<br>具体来说，volatile的内存屏障包括以下两种：</p><ul><li>写屏障（Write Barrier）：当一个线程写入一个volatile变量时，JVM会在写操作之后插入一条写屏障指令，以确保该变量的修改能够被其他线程立即看到。</li><li>读屏障（Read Barrier）：当一个线程读取一个volatile变量时，JVM会在读操作之前插入一条读屏障指令，以确保该变量的值是最新的（即保证了前面的写操作已经完成）。</li></ul><p>使用volatile的内存屏障可以确保多个线程之间的内存可见性和有序性，避免了出现数据不一致的问题。但需要注意的是，volatile并<strong>不能保证原子性</strong>，如果需要保证操作的原子性，需要使用其他的同步机制，如synchronized关键字或者java.util.concurrent包中提供的原子类。</p></li><li><p>CAS？<br>CAS：全称 Compare and swap，即<strong>比较并交换</strong>，它是一条 <strong>CPU 同步原语</strong>。是一种硬件对并发的支持，针对多处理器操作而设计的一种特殊指令，用于<strong>管理对共享数据的并发访问</strong>。<br>CAS 包含了 3 个操作数：旧的预期值 A（刚开始读的），需要读写的内存值 V（修改前一刻读的），要修改的更新值 B。只有当V&#x3D;A时才修改（说明没有被动过）。如果不等，重新进行比较和更新。</p><p>ABA问题：并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况。此时A已经非彼A，数据即使成功修改，也可能有问题。可以通过<strong>AtomicStampedReference</strong>解决ABA问题，它，一个带有标记的原子引用类，通过控制变量值的版本来保证CAS的正确性。</p></li><li><p>ThreadLocal？<br>ThreadLocal，即线程本地变量。如果创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到<strong>线程隔离</strong>的作用，避免了线程安全问题。</p><p>实现原理：通过一个<strong>ThreadLocalMap</strong>来实现的，每个线程都有一个ThreadLocalMap实例。在ThreadLocalMap中，每个ThreadLocal对象都有一个对应的Entry对象，Entry对象中保存了该线程对应的变量值。每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。</p></li><li><p>ThreadLocal内存泄漏问题？<br> ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，⽽ value 是强引⽤。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。 假如我们不做任何措施的话，value 永远⽆法被GC 回收，这个时候就可能会产⽣内存泄露。</p><p>如何解决内存泄漏问题？<br>使用完ThreadLocal后，及时调用remove()方法释放内存空间。</p></li><li><p>AQS是什么？<br>AQS全称是AbstractQueuedSynchronizer，是Java并发包中用于<strong>实现锁、同步器等高级同步功能的基础框架</strong>。它提供了一种基于FIFO等待队列的锁获取与释放的机制，同时也提供了一些方法供开发者自定义同步器。</p><p>AQS的原理可以简单概括为以下三个方面：</p><ul><li>状态管理：AQS通过维护一个状态变量来管理同步器的状态，状态可以是任意Java数据类型，如int、boolean等，通常表示锁的持有次数或资源的数量等。</li><li>等待队列：AQS通过维护一个等待队列来管理处于阻塞状态的线程，等待队列是一个FIFO队列，由多个Node节点构成，Node节点保存了线程的引用和状态等信息。</li><li>CAS操作：AQS使用CAS操作来保证并发安全性，CAS操作可以在不使用锁的情况下，实现对内存中的值的原子操作。AQS中使用CAS操作来实现锁的获取和释放操作，在获取锁时，它会使用CAS操作尝试获取锁，如果CAS操作失败，线程会被阻塞，并加入到等待队列中，等待其他线程释放锁并通知它，在释放锁时，它会使用CAS操作更新锁的状态，并从等待队列中唤醒一个或多个线程，使它们尝试重新获取锁。</li></ul></li><li><p>线程池核心参数？</p><ul><li>corePoolSize：核心线程大小。</li><li>maximumPoolSize ：表示线程池中允许存在的最大线程数量。</li><li>keepAliveTime：线程空闲时间，表示空闲线程的存活时间。</li><li>unit：线程空闲时间的单位。</li><li>workQueue：任务队列，用于保存尚未执行的任务。</li><li>threadFactory：线程工厂，用于创建新的线程。</li><li>handler：拒绝策略。</li></ul></li><li><p>为什么使用线程池？<br><strong>降低资源消耗。</strong> 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br><strong>提高响应速度。</strong> 当任务到达时，任务可以不需要的等到线程创建就能立即执行。<br><strong>提高线程的可管理性。</strong>可以进行统一的分配，调优和监控。</p></li><li><p>线程池的拒绝策略有哪些？</p><ul><li>AbortPolicy：<strong>默认饱和策略</strong>。直接丢弃任务，并抛出RejectedExecutionException异常。</li><li>DiscardPolicy：直接丢弃任务，什么都不做。</li><li>CallerRunsPolicy：线程池之外的线程直接调用run方法执行。</li><li>DiscardOldestPolicy：将workQueue队首任务丢弃，将最新线程任务重新加入队列执行。</li></ul></li><li><p>线程池的工作方式？</p><ol><li>初始化线程池：在创建线程池时，需要设置线程池的核心线程数、最大线程数、线程空闲时间、任务队列等参数，并初始化线程池中的线程。</li><li>提交任务：将需要执行的任务提交给线程池，线程池会根据一定的策略将任务分配给空闲线程或新建线程执行。</li><li>执行任务：线程池中的线程会从任务队列中获取任务并执行，执行完成后会返回线程池并等待下一次任务。</li><li>管理线程：线程池会根据线程使用情况动态调整线程池中的线程数量，以保证线程池中的线程数量始终处于一个合适的范围内。</li><li>销毁线程池：在程序结束时，需要调用线程池的shutdown()方法来销毁线程池，同时释放线程池中的线程资源。</li></ol></li><li><p>常用的线程池？</p><ul><li>FixedThreadPool：线程池中的线程数量固定不变，适用于执行时间较短的任务，可以避免线程的频繁创建和销毁，提高了系统的性能。</li><li>CachedThreadPool：线程池中的线程数量不固定，适用于执行时间较短的任务，当任务量增加时，会动态增加线程数量；当任务减少时，会动态减少线程数量。</li><li>ScheduledThreadPool：线程池中的线程数量固定不变，适用于需要定时执行任务的场景，比如定时发送邮件、定时备份数据等。</li><li>SingleThreadPool：线程池中只有一个线程，适用于需要顺序执行任务的场景，确保所有任务按照指定的顺序执行。</li><li>WorkStealingPool：Java8 新增的线程池，线程数量可以动态调整，每个线程都有自己的任务队列，可以从其他线程的队列中“窃取”任务，提高线程的利用率。</li></ul><p>怎么创建线程池？<br>方式一：通过<strong>ThreadPoolExecutor</strong>构造函数来创建（推荐）<br>方式二：通过 Executor 框架的工具类 Executors 来创建。</p></li><li><p>线程池常用的阻塞队列有哪些？</p><ul><li><strong>LinkedBlockingQueue</strong> ： FixedThreadPool 和 SingleThreadExector 使用，容量为 Integer.MAX_VALUE ，可以认为是无界队列。由于 FixedThreadPool 线程池的线程数是固定的，所以没有办法增加特别多的线程来处理任务，这时就需要 LinkedBlockingQueue 这样一个没有容量限制的阻塞队列来存放任务。</li><li><strong>SynchronousQueue</strong>：CachedThreadPool使用。</li><li><strong>DelayedWorkQueue</strong>： ScheduledThreadPool 和 SingleThreadScheduledExecutor使用。</li></ul></li></ol><h2 id="三、JVM"><a href="#三、JVM" class="headerlink" title="三、JVM"></a>三、JVM</h2><ol><li><p>JVM内存区域？</p><ul><li>程序计数器：<strong>线程私有</strong>的，是一块很小的内存空间，作为当前线程的行号指示器，用于记录当前虚拟机正在执行的线程指令地址；</li><li>虚拟机栈：<strong>线程私有</strong>的，每个方法执行的时候都会创建一个栈帧，用于存储<strong>局部变量表</strong>、<strong>操作数</strong>、<strong>动态链接</strong>和<strong>方法返回</strong>等信息，当线程请求的栈深度超过了虚拟机允许的最大深度时，就会抛出StackOverFlowError；</li><li>本地方法栈：<strong>线程私有</strong>的，保存的是<strong>native方法</strong>的信息，当一个jvm创建的线程调用native方法后，jvm不会在虚拟机栈中为该线程创建栈帧，而是简单的动态链接并直接调用该方法；</li><li>堆：java堆是所有线程共享的一块内存，几乎所有<strong>对象的实例</strong>和<strong>数组</strong>都要在堆上分配内存，因此该区域经常发生垃圾回收的操作；</li><li>方法区：存放<strong>已被加载的类信息、常量、静态变量</strong>、<strong>即时编译器编译后的代码数据</strong>。即永久代，在jdk1.8中不存在方法区了，被元数据区替代了，原方法区被分成两部分；1：加载的类信息，2：运行时常量池；加载的类信息被保存在元数据区中，运行时常量池保存在堆中；</li></ul></li><li><p>垃圾回收的算法？</p><ul><li><strong>标记清楚法</strong>：利用可达性去遍历内存，把存活对象和垃圾对象进行标记；在遍历一遍，将所有标记的对象回收掉； 特点：效率不行，标记和清除的效率都不高；标记和清除后会产生大量的<strong>不连续的空间碎片</strong>，可能会导致之后程序运行的时候需分配大对象而找不到连续分片而不得不触发一次GC；</li><li><strong>标记整理法</strong>：利用可达性去遍历内存，把存活对象和垃圾对象进行标记； 将所有的存活的对象向一段移动，将端边界以外的对象都回收掉； 特点：适用于存活对象多，垃圾少的情况；需要整理的过程，无空间碎片产生；标记整理法需要将所有存活的对象复制到一段新的内存区域中，这会产生<strong>额外的开销</strong>，并且可能会导致频繁的内存分配和释放操作。</li><li><strong>复制算法</strong>：将内存按照容量大小分为大小相等的两块，每次只使用一块，当一块使用完了，就将还存活的对象移到另一块上，然后在把使用过的内存空间移除； 特点：不会产生空间碎片；<strong>内存使用率极低</strong>；</li><li><strong>分代收集法</strong>：根据内存对象的存活周期不同，将内存划分成几块，java虚拟机一般将内存分成新生代和老生代，在新生代中，有大量对象死去和少量对象存活，所以采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集；老年代中因为对象的存活率极高，没有额外的空间对他进行分配担保，所以采用标记清理或者标记整理算法进行回收；</li></ul></li><li><p>如何判断对象是否存活？</p><ul><li><strong>引用计数法</strong>： 给每一个对象设置一个引用计数器，当有一个地方引用该对象的时候，引用计数器就+1，引用失效时，引用计数器就-1；当引用计数器为0的时候，就说明这个对象没有被引用，也就是垃圾对象，等待回收； 缺点：无法解决循环引用的问题，当A引用B，B也引用A的时候，此时AB对象的引用都不为0，此时也就无法垃圾回收，所以一般主流虚拟机都不采用这个方法；</li><li><strong>可达性分析法</strong>： 从一个被称为GC Roots的对象向下搜索，如果一个对象到GC Roots没有任何引用链相连接时，说明此对象不可用，在java中可以作为GC Roots的对象有以下几种：<ul><li>虚拟机栈中引用的对象</li><li>方法区类静态属性引用的变量</li><li>方法区常量池引用的对象</li><li>本地方法栈JNI引用的对象</li></ul></li></ul></li><li><p>CMS垃圾回收器？<br>一种以低停顿时间为目标的垃圾回收器。</p><p>初始标记阶段：该阶段是 <strong>STW</strong> 阶段，用于标记 GC Root 能直接关联到的对象，标记完成后，GC 线程会立即停止所有应用程序的线程，进入下一阶段。</p><p>并发标记阶段：该阶段与应用程序线程并发执行，标记所有 GC Root 可达的对象，并将这些对象标记为“存活”。</p><p>重新标记阶段：该阶段是 <strong>STW</strong> 阶段，用于标记在并发标记阶段中因应用程序线程的执行而产生的新对象，以及在并发标记阶段中发生变化的对象。标记完成后，GC 线程会立即停止所有应用程序的线程，进入下一阶段。</p><p>并发清除阶段：该阶段与应用程序线程并发执行，对未被标记为“存活”的对象进行清除。</p><p>问题：无法清理浮动垃圾，内存碎片问题（CMS是一款基于“标记-清除”算法实现的回收器）。</p></li><li><p>G1回收器？<br>通过将整个堆空间划分为多个 Region 区域，并采用增量式回收方式</p><p>初始标记：标记GC ROOT能关联到的对象，需要<strong>STW</strong>(停顿线程）；</p><p>并发标记：从GCRoots的直接关联对象开始遍历整个对象图的过程，扫描完成后还会重新处理并发标记过程中产生变动的对象；</p><p>最终标记：短暂暂停用户线程，再处理一次，需要<strong>STW</strong>；</p><p>筛选回收：更新Region的统计数据，对每个Region的回收价值和成本排序，根据用户设置的停顿时间制定回收计划。再把需要回收的Region中存活对象复制到空的Region，同时清理旧的Region。需要<strong>STW</strong>。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/post/ff05b5bf.html"/>
      <url>/post/ff05b5bf.html</url>
      
        <content type="html"><![CDATA[<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><p>好好学习</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
